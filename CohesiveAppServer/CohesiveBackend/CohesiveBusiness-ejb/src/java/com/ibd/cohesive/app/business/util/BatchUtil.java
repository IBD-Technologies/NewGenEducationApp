/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.ibd.cohesive.app.business.util;

import com.ibd.cohesive.app.business.util.dependencyInjection.AppDependencyInjection;
import com.ibd.cohesive.db.core.metadata.IMetaDataService;
import com.ibd.cohesive.db.readbuffer.DBRecord;
import com.ibd.cohesive.db.readbuffer.IDBReadBufferService;
import com.ibd.cohesive.db.session.DBSession;
import com.ibd.cohesive.db.transaction.IDBTransactionService;
import com.ibd.cohesive.db.transaction.transactioncontol.ITransactionControlService;
import com.ibd.cohesive.util.IBDProperties;
import com.ibd.cohesive.util.debugger.Debug;
import com.ibd.cohesive.util.exceptions.BSProcessingException;
import com.ibd.cohesive.util.exceptions.BSValidationException;
import com.ibd.cohesive.util.exceptions.DBProcessingException;
import com.ibd.cohesive.util.exceptions.DBValidationException;
import com.ibd.cohesive.util.session.CohesiveSession;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 *
 * @author DELL
 */
public class BatchUtil {
    Debug debug;
    IBDProperties i_db_properties;

    public IBDProperties getI_db_properties() {
        return i_db_properties;
    }

    public void setI_db_properties(IBDProperties i_db_properties) {
        this.i_db_properties = i_db_properties;
    }
    
    public Debug getDebug() {
        return debug;
    }

    public void setDebug(Debug debug) {
        this.debug = debug;
    }
    
   
    public BatchUtil(){
        
    }
    
    public void instituteErrorHandler(String p_instituteID,String p_businessDate,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside instituteErrorHandler");
            dbg("exception"+e);
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            tc=inject.getTransactionControlService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_batchMap=null; 
            Map<String,List<DBRecord>>batchWiseGroup=null;
            
            try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            int maxSequence=  getInstituteMaxSequence(p_businessDate,p_instituteID,inject,session,dbSession);
            
            boolean exceptionRaised=false;  
           try{
            
            l_batchMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "BATCH_STATUS", session, dbSession);
       
            
            batchWiseGroup=   l_batchMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.groupingBy(rec->rec.getRecord().get(1).trim()));
            
            
            
            
           }catch(Exception exc){
               exceptionRaised=true;
               column_to_Update=new HashMap();
               column_to_Update.put("3", "F");
               column_to_Update.put("5", endTime);
               String[] l_pkey={p_instituteID,p_businessDate,Integer.toString(maxSequence)};
               dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "INSTITUTE_EOD_STATUS", l_pkey, column_to_Update,session); 
               tc.commit(session, dbSession);
               updateInstituteErrorTable(p_businessDate,p_instituteID,exc,l_pkey,inject,session,dbSession);
           } 
           
           
           
           if(!exceptionRaised){
            
               
//                int successRecords= l_batchMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(2).trim().equals(p_businessDate)&&rec.getRecord().get(5).trim().equals("S")).collect(Collectors.toList()).size();
//                int failedRecords=  l_batchMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(2).trim().equals(p_businessDate)&&rec.getRecord().get(5).trim().equals("F")).collect(Collectors.toList()).size();
//                dbg("successRecords"+successRecords);
//                dbg("failedRecords"+failedRecords);
//                dbg("end time"+endTime);
               Iterator<String>batchIterator=batchWiseGroup.keySet().iterator();
               int successRecords=0;
               int failedRecords=0;
               while(batchIterator.hasNext()){
                   
                   String batchName=batchIterator.next();
                   int batchMaxSequence=getBatchMaxSequence(p_businessDate,p_instituteID,batchName,inject,session,dbSession);
                   
                   List<DBRecord>sucRecord=l_batchMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(batchName)&&rec.getRecord().get(2).trim().equals(p_businessDate)&&rec.getRecord().get(9).trim().equals(Integer.toString(batchMaxSequence))&&rec.getRecord().get(5).trim().equals("S")).collect(Collectors.toList());
                   
                   successRecords=successRecords+sucRecord.size();
                   
                   List<DBRecord>failRecord=l_batchMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(batchName)&&rec.getRecord().get(2).trim().equals(p_businessDate)&&rec.getRecord().get(9).trim().equals(Integer.toString(batchMaxSequence))&&rec.getRecord().get(5).trim().equals("F")).collect(Collectors.toList());
                   
                   failedRecords=failedRecords+failRecord.size();
                   
                   
               }

                       column_to_Update=new HashMap();
                       column_to_Update.put("3", "F");
                       column_to_Update.put("5", endTime);
                       column_to_Update.put("6", Integer.toString(successRecords));
                       column_to_Update.put("7", Integer.toString(failedRecords));
                       String[] l_pkey={p_instituteID,p_businessDate,Integer.toString(maxSequence)};
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "INSTITUTE_EOD_STATUS", l_pkey, column_to_Update,session); 
                       tc.commit(session, dbSession);
                       updateInstituteErrorTable(p_businessDate,p_instituteID,e,l_pkey,inject,session,dbSession);
           }         
               
                   
                   
            
        dbg("end of instituteErrorHandler");     
             tc.commit(session, dbSession);
     }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
    private void updateInstituteErrorTable(String p_businessDate,String p_instituteID,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            dbg("inside update institute error table");
            ITransactionControlService tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            BusinessService bs=inject.getBusinessService(session);
            String currentTime=bs.getCurrentDateTime();
            
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
             boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "INSTITUTE_EOD_STATUS_ERROR", l_pkey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                        column_to_Update=new HashMap();
                        column_to_Update.put("3", l_replacedException);//special character replacement
                        dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "INSTITUTE_EOD_STATUS_ERROR", l_pkey, column_to_Update,session); 
                   }else{
                       
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 107,p_instituteID,p_businessDate,l_replacedException);
                   
                   }  
            
            tc.commit(session, dbSession);
            dbg("end of update institute error table");
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
      }catch(BSProcessingException ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
        
    }
    
    public void instituteSucessHandler(String p_instituteID,String p_businessDate,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside instituteSucessHandler");
            Map<String,String>column_to_Update;
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            tc=inject.getTransactionControlService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_batchMap=null;
            Map<String,List<DBRecord>>batchWiseGroup=null;
            
           int maxSequence=  getInstituteMaxSequence(p_businessDate,p_instituteID,inject,session,dbSession);
            
           boolean exceptionRaised=false;  
           try{
            
            l_batchMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "BATCH_STATUS", session, dbSession);
       
            
            batchWiseGroup=   l_batchMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.groupingBy(rec->rec.getRecord().get(1).trim()));
            
           }catch(Exception exc){
               exceptionRaised=true;
               column_to_Update=new HashMap();
               column_to_Update.put("3", "F");
               column_to_Update.put("5", endTime);
               String[] l_pkey={p_instituteID,p_businessDate,Integer.toString(maxSequence)};
               dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "INSTITUTE_EOD_STATUS", l_pkey, column_to_Update,session); 
               tc.commit(session, dbSession);
               updateInstituteErrorTable(p_businessDate,p_instituteID,exc,l_pkey,inject,session,dbSession);
           } 
            
            
           if(!exceptionRaised){
           
//            int successRecords= l_batchMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(2).trim().equals(p_businessDate)&&rec.getRecord().get(5).trim().equals("S")).collect(Collectors.toList()).size();
//            int failedRecords=  l_batchMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(2).trim().equals(p_businessDate)&&rec.getRecord().get(5).trim().equals("F")).collect(Collectors.toList()).size();
        
              Iterator<String>batchIterator=batchWiseGroup.keySet().iterator();
               int successRecords=0;
               int failedRecords=0;
               while(batchIterator.hasNext()){
                   
                   String batchName=batchIterator.next();
                   int batchMaxSequence=getBatchMaxSequence(p_businessDate,p_instituteID,batchName,inject,session,dbSession);
                   
                   List<DBRecord>sucRecord=l_batchMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(batchName)&&rec.getRecord().get(2).trim().equals(p_businessDate)&&rec.getRecord().get(9).trim().equals(Integer.toString(batchMaxSequence))&&rec.getRecord().get(5).trim().equals("S")).collect(Collectors.toList());
                   
                   successRecords=successRecords+sucRecord.size();
                   
                   List<DBRecord>failRecord=l_batchMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(batchName)&&rec.getRecord().get(2).trim().equals(p_businessDate)&&rec.getRecord().get(9).trim().equals(Integer.toString(batchMaxSequence))&&rec.getRecord().get(5).trim().equals("F")).collect(Collectors.toList());
                   
                   failedRecords=failedRecords+failRecord.size();
                   
                   
               }


            dbg("successRecords"+successRecords);
            dbg("failedRecords"+failedRecords);
            dbg("end time"+endTime);
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "S");
                   column_to_Update.put("5", endTime);
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   String[] l_pkey={p_instituteID,p_businessDate,Integer.toString(maxSequence)};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "INSTITUTE_EOD_STATUS", l_pkey, column_to_Update,session); 
           }      
            
             dbg("end of instituteSucessHandler");
                          tc.commit(session, dbSession);
     }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
        
    }
    
    
    public void appErrorHandler(String p_businessDate,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession){
         ITransactionControlService tc=null;
        try{
            dbg("inside appErrorHandler");
            dbg("exception"+e);
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            tc=inject.getTransactionControlService();
            BusinessService bs=inject.getBusinessService(session);
            Map<String,DBRecord>l_batchMap=null;
            String endTime=bs.getCurrentDateTime();
            Map<String,List<DBRecord>>instituteGroup=null;
            
            try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
            int appMaxSequence= getAppMaxSequence(p_businessDate,inject,session,dbSession);
            
            
            
            boolean exceptionRaised=false;  
           try{
            
            l_batchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "INSTITUTE_EOD_STATUS", session, dbSession);
       
            instituteGroup=   l_batchMap.values().stream().collect(Collectors.groupingBy(rec->rec.getRecord().get(0).trim()));
            

           }catch(Exception exc){
               exceptionRaised=true;
               column_to_Update=new HashMap();
               column_to_Update.put("3", endTime);
               column_to_Update.put("4", "F");
               String[] l_pkey={p_businessDate,Integer.toString(appMaxSequence)};
               dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "APP_EOD_STATUS", l_pkey, column_to_Update,session); 
               tc.commit(session, dbSession);
               updateAppErrorTable(p_businessDate,exc,l_pkey,inject,session,dbSession);
           } 
            
           if(!exceptionRaised){
           
               Iterator<String>instituteIterator=instituteGroup.keySet().iterator();
               int successRecords=0;
               int failedRecords=0;
               while(instituteIterator.hasNext()){
                   
                   String instituteID=instituteIterator.next();
                   int instituteMaxSequence=getInstituteMaxSequence(p_businessDate,instituteID,inject,session,dbSession);
                   
                   List<DBRecord>sucRecord=l_batchMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(instituteID)&&rec.getRecord().get(1).trim().equals(p_businessDate)&&rec.getRecord().get(8).trim().equals(Integer.toString(instituteMaxSequence))&&rec.getRecord().get(2).trim().equals("S")).collect(Collectors.toList());
                   
                   successRecords=successRecords+sucRecord.size();
                   
                   List<DBRecord>failRecord=l_batchMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(instituteID)&&rec.getRecord().get(1).trim().equals(p_businessDate)&&rec.getRecord().get(8).trim().equals(Integer.toString(instituteMaxSequence))&&rec.getRecord().get(2).trim().equals("F")).collect(Collectors.toList());
                   
                   failedRecords=failedRecords+failRecord.size();
                   
               }
               
               
//                int successRecords= l_batchMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(p_businessDate)&&rec.getRecord().get(2).trim().equals("S")).collect(Collectors.toList()).size();
//                int failedRecords=  l_batchMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(p_businessDate)&&rec.getRecord().get(2).trim().equals("F")).collect(Collectors.toList()).size();
                dbg("successRecords"+successRecords);
                dbg("failedRecords"+failedRecords);
                dbg("end time"+endTime);


                       column_to_Update=new HashMap();
                       column_to_Update.put("3", endTime);
                       column_to_Update.put("4", "F");
                       column_to_Update.put("6", Integer.toString(successRecords));
                       column_to_Update.put("7", Integer.toString(failedRecords));
                       String[] l_pkey={p_businessDate,Integer.toString(appMaxSequence)};
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "APP_EOD_STATUS", l_pkey, column_to_Update,session); 
                       tc.commit(session, dbSession);
                       updateAppErrorTable(p_businessDate,e,l_pkey,inject,session,dbSession);
                  
           }
                   
  
           dbg("end of appErrorHandler");        
        tc.commit(session, dbSession);
     }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    private void updateAppErrorTable(String p_businessDate,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            dbg("inside update app error table");
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            ITransactionControlService tc=inject.getTransactionControlService();
            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            BusinessService bs=inject.getBusinessService(session);
            String currentTime=bs.getCurrentDateTime();
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
             boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "APP_EOD_STATUS_ERROR", l_pkey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                        column_to_Update=new HashMap();
                        column_to_Update.put("2", l_replacedException);
                        dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "APP_EOD_STATUS_ERROR", l_pkey, column_to_Update,session);  
                   }else{
                       
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 108,p_businessDate,l_replacedException);
                   
                   }
            
            tc.commit(session, dbSession);
            dbg("end of update app error table");
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
      }catch(BSProcessingException ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
        
    }
    
    
    public int getAppMaxSequence(String businessDate,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getAppMaxSequence");  
         
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            
         Map<String,DBRecord>l_appEodMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate, "BATCH", "APP_EOD_STATUS", session, dbSession,true);
           
         int  maxSequence= l_appEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(7).trim())).max().getAsInt();   
            
         dbg("end of getAppMaxSequence");
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
    
    public int getAppHistoryMaxSequence(String businessDate,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getAppHistoryMaxSequence");  
         
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         Map<String,DBRecord>l_appEodMap=null;
         int  maxSequence=0;
            
         try{
         
              l_appEodMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate, "BATCH", "APP_EOD_STATUS_HISTORY", session, dbSession,true);
           
              maxSequence= l_appEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(7).trim())).max().getAsInt();   
              
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         
            
         dbg("end of getAppHistoryMaxSequence");
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
    
    public int getInstituteMaxSequence(String businessDate,String institueID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getInstituteMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         
         int maxSequence=0;
         
         
         try{
         
            
         Map<String,DBRecord>l_instituteEodMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate, "BATCH", "INSTITUTE_EOD_STATUS", session, dbSession,true);
           
         List<DBRecord>filteredList= l_instituteEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(businessDate)).collect(Collectors.toList());
            
         if(!filteredList.isEmpty()){
             
             maxSequence=filteredList.stream().mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
             
         }else{
             
             maxSequence=0;
         }
         
         
         
          }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         
         
         dbg("end of getInstituteMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
    
    public int getInstituteHistoryMaxSequence(String businessDate,String institueID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getInstituteHistoryMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         int  maxSequence=0;
            
         try{
         
             Map<String,DBRecord>l_instituteEodMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate, "BATCH", "INSTITUTE_EOD_STATUS_HISTORY", session, dbSession,true);

             List<DBRecord>filteredList= l_instituteEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(businessDate)).collect(Collectors.toList());
            
             if(!filteredList.isEmpty()){

                 maxSequence=filteredList.stream().mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();

             }else{

                 maxSequence=0;
             }
            
         
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         
         
         dbg("end of getInstituteHistoryMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
     public int getBatchMaxSequence(String businessDate,String instituteID,String batchName,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getBatchMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            
         int maxSequence=0;
         
         try{
         
         
         Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate, "BATCH", "BATCH_STATUS", session, dbSession,true);
           
         
         List<DBRecord>filteredRecords= l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(instituteID)&&rec.getRecord().get(1).trim().equals(batchName)&&rec.getRecord().get(2).trim().equals(businessDate)).collect(Collectors.toList());
         
         
         if(filteredRecords.isEmpty()){
             
             dbg("filteredRecords.isEmpty()");
             maxSequence=0;
         }else{
         
         
            maxSequence= l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(instituteID)&&rec.getRecord().get(1).trim().equals(batchName)&&rec.getRecord().get(2).trim().equals(businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(9).trim())).max().getAsInt();
            
         }
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         
         dbg("end of getBatchMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
    
    
    public int getBatchHistoryMaxSequence(String businessDate,String institueID,String batchName,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getBatchHistoryMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         int  maxSequence=0;
         try{
            
             Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+institueID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate, "BATCH", "BATCH_STATUS_HISTORY", session, dbSession,true);

             
             
             
             
          List<DBRecord>filteredRecords= l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(batchName)&&rec.getRecord().get(2).trim().equals(businessDate)).collect(Collectors.toList());
         
         
         if(filteredRecords.isEmpty()){
             
             dbg("filteredRecords.isEmpty()");
             maxSequence=0;
         }else{
         
         
            maxSequence= l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(batchName)&&rec.getRecord().get(2).trim().equals(businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(9).trim())).max().getAsInt();
            
         }            
         
             
             
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         dbg("end of getBatchHistoryMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
    
   public int getMarkHistoryMaxSequence(String businessDate,String institueID,String standard,String section,String exam,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getOtherActivityHistoryMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         int  maxSequence=0;
         
         try{
         
            
             Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+institueID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate, "BATCH", "MARK_BATCH_STATUS_HISTORY", session, dbSession,true);

//             maxSequence= l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(OtherActivityID)&&rec.getRecord().get(2).trim().equals(businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
            
             
             List<DBRecord>filteredList=l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(standard)&&rec.getRecord().get(2).trim().equals(section)&&rec.getRecord().get(3).trim().equals(exam)&&rec.getRecord().get(4).trim().equals(businessDate)).collect(Collectors.toList());
         
             if(!filteredList.isEmpty()){
             
                maxSequence= filteredList.stream().mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
            
             }else{
                 maxSequence=0;
             }
             
         
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         dbg("end of getOtherActivityHistoryMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
    
    
    public int getNotificationHistoryMaxSequence(String businessDate,String institueID,String notificationID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getNotificationHistoryMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         int  maxSequence=0;
         
         try{
         
            
             Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+institueID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate, "BATCH", "NOTIFICATION_EOD_STATUS_HISTORY", session, dbSession,true);

             maxSequence= l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(notificationID)&&rec.getRecord().get(2).trim().equals(businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
            
         
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         dbg("end of getNotificationHistoryMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
     public int getFeeHistoryMaxSequence(String businessDate,String institueID,String feeID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getFeeHistoryMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         int  maxSequence=0;
         
         try{
         
            
             Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+institueID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate, "BATCH", "FEE_EOD_STATUS_HISTORY", session, dbSession,true);

             maxSequence= l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(feeID)&&rec.getRecord().get(2).trim().equals(businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
            
         
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         dbg("end of getFeeHistoryMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
    public int getOtherActivityHistoryMaxSequence(String businessDate,String institueID,String OtherActivityID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getOtherActivityHistoryMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         int  maxSequence=0;
         
         try{
         
            
             Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+institueID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate, "BATCH", "OTHER_ACTIVITY_EOD_STATUS_HISTORY", session, dbSession,true);

//             maxSequence= l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(OtherActivityID)&&rec.getRecord().get(2).trim().equals(businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
            
             
             List<DBRecord>filteredList=l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(OtherActivityID)&&rec.getRecord().get(2).trim().equals(businessDate)).collect(Collectors.toList());
         
             if(!filteredList.isEmpty()){
             
                maxSequence= filteredList.stream().mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
            
             }else{
                 maxSequence=0;
             }
             
         
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         dbg("end of getOtherActivityHistoryMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
    
    
     public int getAssignmentHistoryMaxSequence(String businessDate,String institueID,String AssignmentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getAssignmentHistoryMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         int  maxSequence=0;
         
         try{
         
            
             Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+institueID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS_HISTORY", session, dbSession,true);

//             maxSequence= l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(AssignmentID)&&rec.getRecord().get(2).trim().equals(businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
            
             
             List<DBRecord>filteredList=l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(AssignmentID)&&rec.getRecord().get(2).trim().equals(businessDate)).collect(Collectors.toList());
         
             if(!filteredList.isEmpty()){
             
                maxSequence= filteredList.stream().mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
            
             }else{
                 maxSequence=0;
             }
             
         
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         dbg("end of getAssignmentHistoryMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
     
     
      public int getECircularHistoryMaxSequence(String businessDate,String institueID,String ECircularID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getECircularHistoryMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         int  maxSequence=0;
         
         try{
         
            
             Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+institueID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate, "BATCH", "E_CIRCULAR_EOD_STATUS_HISTORY", session, dbSession,true);

//             maxSequence= l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(ECircularID)&&rec.getRecord().get(2).trim().equals(businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
            
             
             List<DBRecord>filteredList=l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(ECircularID)&&rec.getRecord().get(2).trim().equals(businessDate)).collect(Collectors.toList());
         
             if(!filteredList.isEmpty()){
             
                maxSequence= filteredList.stream().mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
            
             }else{
                 maxSequence=0;
             }
             
         
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         dbg("end of getECircularHistoryMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
     
     
//    public int getNotificationMaxSequence(String businessDate,String institueID,String notificationID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        
//        try{
//            
//         dbg("inside getNotificationMaxSequence");  
//            
//         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//         int  maxSequence=0;
//         
//         try{
//         
//            
//             Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+institueID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate, "BATCH", "NOTIFICATION_EOD_STATUS", session, dbSession,true);
//
//             maxSequence= l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(notificationID)&&rec.getRecord().get(2).trim().equals(businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
//            
//         
//         }catch(DBValidationException ex){
//             
//             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
//                 
//                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
//                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
//              
//             }else{
//                 
//                  throw ex;
//             }
//         }
//         
//         
//         dbg("end of getNotificationMaxSequence--->"+maxSequence);
//         return maxSequence;
//     }catch(DBValidationException ex){
//          throw ex;
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          throw new DBProcessingException("DBProcessingException"+ex.toString());
////      }catch(BSProcessingException ex){
////           dbg(ex);
////           throw new BSProcessingException(ex.toString());
//     }catch(Exception ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
//     }
//        
//    }
    
      public int getStudentNotificationHistoryMaxSequence(String businessDate,String institueID,String notificationID,String studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getStudentNotificationHistoryMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         int  maxSequence=0;
         
         try{
            
             Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+institueID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification"+i_db_properties.getProperty("FOLDER_DELIMITER")+notificationID, "BATCH", "STUDENT_NOTIFICATION_EOD_STATUS_HISTORY", session, dbSession,true);

             List<DBRecord>filteredList=l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(notificationID)&&rec.getRecord().get(2).trim().equals(studentID)&&rec.getRecord().get(3).trim().equals(businessDate)).collect(Collectors.toList());
         
             if(!filteredList.isEmpty()){
             
                maxSequence= filteredList.stream().mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
            
             }else{
                 maxSequence=0;
             }
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         dbg("end of getStudentNotificationHistoryMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
      public int getStudentFeeHistoryMaxSequence(String businessDate,String institueID,String feeID,String studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getStudentFeeHistoryMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         int  maxSequence=0;
         
         try{
            
             Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+institueID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Fee"+i_db_properties.getProperty("FOLDER_DELIMITER")+feeID, "BATCH", "STUDENT_FEE_EOD_STATUS_HISTORY", session, dbSession,true);

             List<DBRecord>filteredList=l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(feeID)&&rec.getRecord().get(2).trim().equals(studentID)&&rec.getRecord().get(3).trim().equals(businessDate)).collect(Collectors.toList());
         
             if(!filteredList.isEmpty()){
             
                maxSequence= filteredList.stream().mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
            
             }else{
                 maxSequence=0;
             }
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         dbg("end of getStudentFeeHistoryMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
      public int getStudentOtherActivityHistoryMaxSequence(String businessDate,String institueID,String otherActivityID,String studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getStudentOtherActivityHistoryMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         int  maxSequence=0;
         
         try{
            
             Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+institueID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"OtherActivity"+i_db_properties.getProperty("FOLDER_DELIMITER")+otherActivityID, "BATCH", "STUDENT_OTHER_ACTIVITY_EOD_STATUS_HISTORY", session, dbSession,true);

             List<DBRecord>filteredList=l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(otherActivityID)&&rec.getRecord().get(2).trim().equals(studentID)&&rec.getRecord().get(3).trim().equals(businessDate)).collect(Collectors.toList());
         
             if(!filteredList.isEmpty()){
             
                maxSequence= filteredList.stream().mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
            
             }else{
                 maxSequence=0;
             }
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         dbg("end of getStudentOtherActivityHistoryMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
      public int getStudentEventNotificationHistoryMaxSequence(String businessDate,String instittueID,String studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getStudentEventNotificationHistoryMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         int  maxSequence=0;
         
         try{
            
             Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+instittueID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate, "BATCH", "STUDENT_EVENT_NOTIFICATION_EOD_STATUS_HISTORY", session, dbSession,true);

             List<DBRecord>filteredList=l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(instittueID)&&rec.getRecord().get(1).trim().equals(studentID)&&rec.getRecord().get(2).trim().equals(businessDate)).collect(Collectors.toList());
         
             if(!filteredList.isEmpty()){
             
                maxSequence= filteredList.stream().mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
            
             }else{
                 maxSequence=0;
             }
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         dbg("end of getStudentEventNotificationHistoryMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
      public int getStudentAssignmentHistoryMaxSequence(String businessDate,String institueID,String assignmentID,String studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getStudentAssignmentHistoryMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         int  maxSequence=0;
         
         try{
            
             Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+institueID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Assignment"+i_db_properties.getProperty("FOLDER_DELIMITER")+assignmentID, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS_HISTORY", session, dbSession,true);

             List<DBRecord>filteredList=l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(assignmentID)&&rec.getRecord().get(2).trim().equals(studentID)&&rec.getRecord().get(3).trim().equals(businessDate)).collect(Collectors.toList());
         
             if(!filteredList.isEmpty()){
             
                maxSequence= filteredList.stream().mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
            
             }else{
                 maxSequence=0;
             }
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         dbg("end of getStudentAssignmentHistoryMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
       public int getStudentECircularHistoryMaxSequence(String businessDate,String institueID,String eCircularID,String studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getStudentECircularHistoryMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         int  maxSequence=0;
         
         try{
            
             Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+institueID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+eCircularID, "BATCH", "STUDENT_E_CIRCULAR_EOD_STATUS_HISTORY", session, dbSession,true);

             List<DBRecord>filteredList=l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(eCircularID)&&rec.getRecord().get(2).trim().equals(studentID)&&rec.getRecord().get(3).trim().equals(businessDate)).collect(Collectors.toList());
         
             if(!filteredList.isEmpty()){
             
                maxSequence= filteredList.stream().mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
            
             }else{
                 maxSequence=0;
             }
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         dbg("end of getStudentECircularHistoryMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
       
       
public int getTeacherECircularHistoryMaxSequence(String businessDate,String institueID,String eCircularID,String teacherID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            
         dbg("inside getTeacherECircularHistoryMaxSequence");  
            
         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
         int  maxSequence=0;
         
         try{
            
             Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+institueID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+eCircularID, "BATCH", "TEACHER_E_CIRCULAR_EOD_STATUS_HISTORY", session, dbSession,true);

             List<DBRecord>filteredList=l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(eCircularID)&&rec.getRecord().get(2).trim().equals(teacherID)&&rec.getRecord().get(3).trim().equals(businessDate)).collect(Collectors.toList());
         
             if(!filteredList.isEmpty()){
             
                maxSequence= filteredList.stream().mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
            
             }else{
                 maxSequence=0;
             }
         }catch(DBValidationException ex){
             
             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
             }else{
                 
                  throw ex;
             }
         }
         
         
         dbg("end of getTeacherECircularHistoryMaxSequence--->"+maxSequence);
         return maxSequence;
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
    }
       
//        public int getStudentNotificationMaxSequence(String businessDate,String institueID,String notificationID,String studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        
//        try{
//            
//         dbg("inside getStudentNotificationMaxSequence");  
//            
//         IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//         int  maxSequence=0;
//         
//         try{
//            
//             Map<String,DBRecord>l_batchEodMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+institueID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification"+i_db_properties.getProperty("FOLDER_DELIMITER")+notificationID, "BATCH", "STUDENT_NOTIFICATION_EOD_STATUS", session, dbSession,true);
//
//               maxSequence= l_batchEodMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(institueID)&&rec.getRecord().get(1).trim().equals(notificationID)&&rec.getRecord().get(2).trim().equals(studentID)&&rec.getRecord().get(3).trim().equals(businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
//            
//         
//         }catch(DBValidationException ex){
//             
//             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
//                 
//                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
//                  session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
//              
//             }else{
//                 
//                  throw ex;
//             }
//         }
//         
//         
//         dbg("end of getStudentNotificationMaxSequence--->"+maxSequence);
//         return maxSequence;
//     }catch(DBValidationException ex){
//          throw ex;
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          throw new DBProcessingException("DBProcessingException"+ex.toString());
////      }catch(BSProcessingException ex){
////           dbg(ex);
////           throw new BSProcessingException(ex.toString());
//     }catch(Exception ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
//     }
//        
//    }
    
     public void appSuccessHandler(String p_businessDate,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside appSuccessHandler");
            Map<String,String>column_to_Update;
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            tc=inject.getTransactionControlService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_batchMap=null;
            Map<String,List<DBRecord>>instituteGroup=null;
           
            int appMaxSequence= getAppMaxSequence(p_businessDate,inject,session,dbSession);
            
            
            
            boolean exceptionRaised=false;  
           try{
            
            l_batchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "INSTITUTE_EOD_STATUS", session, dbSession);
       
            
            instituteGroup=   l_batchMap.values().stream().collect(Collectors.groupingBy(rec->rec.getRecord().get(0).trim()));
            
           }catch(Exception exc){
               exceptionRaised=true;
               column_to_Update=new HashMap();
               column_to_Update.put("4", "F");
               column_to_Update.put("3", endTime);
               String[] l_pkey={p_businessDate,Integer.toString(appMaxSequence)};
               dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "APP_EOD_STATUS", l_pkey, column_to_Update,session); 
               tc.commit(session, dbSession);
               updateAppErrorTable(p_businessDate,exc,l_pkey,inject,session,dbSession);
           }
            
           if(!exceptionRaised){ 
               
               Iterator<String>instituteIterator=instituteGroup.keySet().iterator();
               int successRecords=0;
               int failedRecords=0;
               while(instituteIterator.hasNext()){
                   
                   String instituteID=instituteIterator.next();
                   int instituteMaxSequence=getInstituteMaxSequence(p_businessDate,instituteID,inject,session,dbSession);
                   
                   List<DBRecord>sucRecord=l_batchMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(instituteID)&&rec.getRecord().get(1).trim().equals(p_businessDate)&&rec.getRecord().get(8).trim().equals(Integer.toString(instituteMaxSequence))&&rec.getRecord().get(2).trim().equals("S")).collect(Collectors.toList());
                   
                   successRecords=successRecords+sucRecord.size();
                   
                   List<DBRecord>failRecord=l_batchMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(instituteID)&&rec.getRecord().get(1).trim().equals(p_businessDate)&&rec.getRecord().get(8).trim().equals(Integer.toString(instituteMaxSequence))&&rec.getRecord().get(2).trim().equals("F")).collect(Collectors.toList());
                   
                   failedRecords=failedRecords+failRecord.size();
                   
               }
               
//                int successRecords= l_batchMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(p_businessDate)&&rec.getRecord().get(2).trim().equals("S")).collect(Collectors.toList()).size();
//                int failedRecords=  l_batchMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(p_businessDate)&&rec.getRecord().get(2).trim().equals("F")).collect(Collectors.toList()).size();
                dbg("successRecords"+successRecords);
                dbg("failedRecords"+failedRecords);
                dbg("end time"+endTime);

                       column_to_Update=new HashMap();
                       column_to_Update.put("3", endTime);
                       column_to_Update.put("4", "S");
                       column_to_Update.put("6", Integer.toString(successRecords));
                       column_to_Update.put("7", Integer.toString(failedRecords));
                       String[] l_pkey={p_businessDate,Integer.toString(appMaxSequence)};
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "APP_EOD_STATUS", l_pkey, column_to_Update,session); 
           }
            dbg("end of appSuccessHandler");       
            tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
     public void batchErrorHandler(String p_instituteID,String l_businessDate,Exception e,String p_batchName,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside batchErrorHandler");
            dbg("p_batchName"+p_batchName);
            dbg("exception"+e);
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            tc=inject.getTransactionControlService();
            BusinessService bs=inject.getBusinessService(session);
            column_to_Update=new HashMap();
            String endTime=bs.getCurrentDateTime();
            
            try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
            int maxSequence=getBatchMaxSequence(l_businessDate,p_instituteID,p_batchName,inject,session,dbSession);
            
            String[] l_pkey={p_instituteID,p_batchName,l_businessDate,Integer.toString(maxSequence)};
            boolean exceptionRaised=false; 
            switch(p_batchName){
                
                case "Assignment":
                        Map<String,DBRecord>l_assignmentMap=null;

                               try{ 

                                   l_assignmentMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_assignmentMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_assignmentMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                       break;
                       
                       
                       case "UnAuth":
            
    

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "F");
                           column_to_Update.put("7", Integer.toString(0));
                           column_to_Update.put("8", Integer.toString(0));
                         break;
                       
                       
                       case "ECircular":
                        Map<String,DBRecord>l_eCircularMap=null;

                               try{ 

                                   l_eCircularMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "E_CIRCULAR_EOD_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_eCircularMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_eCircularMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                       break;
                       
                       case "OtherActivity":
                            Map<String,DBRecord>l_otherActvityMap=null;
                               try{ 

                                   l_otherActvityMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "OTHER_ACTIVITY_EOD_STATUS", session, dbSession);

                                   
                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                          if(!exceptionRaised){
                                       
                                       int successRecords= l_otherActvityMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_otherActvityMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "FeeManagement":
                            Map<String,DBRecord>l_feeMap=null;
                               try{ 

                                   l_feeMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_EOD_STATUS", session, dbSession);

                                   
                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                          if(!exceptionRaised){
                                       
                                       int successRecords= l_feeMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_feeMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "FeeNotification":
                            Map<String,DBRecord>l_feeNotificationMap=null;
                               try{ 

                                   l_feeNotificationMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_NOTIFICATION_EOD_STATUS", session, dbSession);

                                   
                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                          if(!exceptionRaised){
                                       
                                       int successRecords= l_feeNotificationMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_feeNotificationMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "EventNotification":
                            Map<String,DBRecord>l_eventNotificationMap=null;
                               try{ 

                                   l_eventNotificationMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EVENT_NOTIFICATION_EOD_STATUS", session, dbSession);

                                   
                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                          if(!exceptionRaised){
                                       
                                       int successRecords= l_eventNotificationMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_eventNotificationMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          
                           case "Notification":
                            Map<String,DBRecord>l_notificationMap=null;
                               try{ 

                                   l_notificationMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "NOTIFICATION_EOD_STATUS", session, dbSession);

                                   
                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                          if(!exceptionRaised){
                                       
                                       int successRecords= l_notificationMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_notificationMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "TimeTable":
                            Map<String,DBRecord>l_timeTableMap=null;

                               try{ 

                                   l_timeTableMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TIMETABLE_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_timeTableMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_timeTableMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "Exam":
                            Map<String,DBRecord>l_examMap=null;

                               try{ 

                                   l_examMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "EXAM_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_examMap.values().stream().filter(rec->rec.getRecord().get(4).trim().equals(l_businessDate)&&rec.getRecord().get(5).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_examMap.values().stream().filter(rec->rec.getRecord().get(4).trim().equals(l_businessDate)&&rec.getRecord().get(5).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "Mark":
                            Map<String,DBRecord>l_markMap=null;

                               try{ 

                                   l_markMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "MARK_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                      int successRecords= l_markMap.values().stream().filter(rec->rec.getRecord().get(5).trim().equals(l_businessDate)&&rec.getRecord().get(6).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                     int failedRecords=  l_markMap.values().stream().filter(rec->rec.getRecord().get(5).trim().equals(l_businessDate)&&rec.getRecord().get(6).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "Attendance":
                            Map<String,DBRecord>l_attendanceMap=null;

                               try{ 

                                   l_attendanceMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ATTENDANCE_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_attendanceMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_attendanceMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                           case "StudentAssignmentArchival":
                            Map<String,DBRecord>l_studentAssignmentArchMap=null;

                               try{ 

                                   l_studentAssignmentArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ASSIGNMENT_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_studentAssignmentArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_studentAssignmentArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "InstituteAssignmentArchival":
                            Map<String,DBRecord>l_instituteAssignmentArchMap=null;

                               try{ 

                                   l_instituteAssignmentArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_ASSIGNMENT_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_instituteAssignmentArchMap.values().stream().filter(rec->rec.getRecord().get( 1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_instituteAssignmentArchMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          case "StudentOtherActivtyArchival":
                            Map<String,DBRecord>l_studentOtherActivtyArchMap=null;

                               try{ 

                                   l_studentOtherActivtyArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_OTHER_ACTIVITY_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_studentOtherActivtyArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_studentOtherActivtyArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "InstituteOtherActivtyArchival":
                            Map<String,DBRecord>l_instituteOtherActivtyArchMap=null;

                               try{ 

                                   l_instituteOtherActivtyArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_OTHER_ACTIVITY_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_instituteOtherActivtyArchMap.values().stream().filter(rec->rec.getRecord().get( 1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_instituteOtherActivtyArchMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          case "StudentFeeArchival":
                            Map<String,DBRecord>l_studentFeeArchMap=null;

                               try{ 

                                   l_studentFeeArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_FEE_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_studentFeeArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_studentFeeArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "InstituteFeeArchival":
                            Map<String,DBRecord>l_instituteFeeArchMap=null;

                               try{ 

                                   l_instituteFeeArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_FEE_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_instituteFeeArchMap.values().stream().filter(rec->rec.getRecord().get( 1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_instituteFeeArchMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "StudentNotificationArchival":
                            Map<String,DBRecord>l_studentNotificationArchMap=null;

                               try{ 

                                   l_studentNotificationArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_NOTIFICATION_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_studentNotificationArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_studentNotificationArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "InstituteNotificationArchival":
                            Map<String,DBRecord>l_instituteNotificationArchMap=null;

                               try{ 

                                   l_instituteNotificationArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_NOTIFICATION_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_instituteNotificationArchMap.values().stream().filter(rec->rec.getRecord().get( 1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_instituteNotificationArchMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          case "StudentMarkArchival":
                            Map<String,DBRecord>l_studentMarkArchMap=null;

                               try{ 

                                   l_studentMarkArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_MARK_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_studentMarkArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_studentMarkArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          case "ClassMarkArchival":
                            Map<String,DBRecord>l_classMarkArchMap=null;

                               try{ 

                                   l_classMarkArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_MARK_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_classMarkArchMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_classMarkArchMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                           case "StudentExamArchival":
                            Map<String,DBRecord>l_studentExamArchMap=null;

                               try{ 

                                   l_studentExamArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EXAM_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_studentExamArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_studentExamArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          case "ClassExamArchival":
                            Map<String,DBRecord>l_classExamArchMap=null;

                               try{ 

                                   l_classExamArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_EXAM_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_classExamArchMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_classExamArchMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "StudentTimeTableArchival":
                            Map<String,DBRecord>l_studentTimeTableArchMap=null;

                               try{ 

                                   l_studentTimeTableArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_TIME_TABLE_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_studentTimeTableArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_studentTimeTableArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          case "ClassTimeTableArchival":
                            Map<String,DBRecord>l_classTimeTableArchMap=null;

                               try{ 

                                   l_classTimeTableArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_TIME_TABLE_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_classTimeTableArchMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_classTimeTableArchMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          case "StudentAttendanceArchival":
                            Map<String,DBRecord>l_studentAttendanceArchMap=null;

                               try{ 

                                   l_studentAttendanceArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ATTENDANCE_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_studentAttendanceArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_studentAttendanceArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          case "ClassAttendanceArchival":
                            Map<String,DBRecord>l_classAttendanceArchMap=null;

                               try{ 

                                   l_classAttendanceArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_ATTENDANCE_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_classAttendanceArchMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_classAttendanceArchMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                           case "StudentLeaveArchival":
                            Map<String,DBRecord>l_studentLeaveArchMap=null;

                               try{ 

                                   l_studentLeaveArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_LEAVE_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_studentLeaveArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_studentLeaveArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                           case "TeacherLeaveArchival":
                            Map<String,DBRecord>l_teacherLeaveArchMap=null;

                               try{ 

                                   l_teacherLeaveArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_LEAVE_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_teacherLeaveArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_teacherLeaveArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "StudentCalenderArchival":
                            Map<String,DBRecord>l_studentCalenderArchMap=null;

                               try{ 

                                   l_studentCalenderArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_CALENDER_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_studentCalenderArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_studentCalenderArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                           case "TeacherCalenderArchival":
                            Map<String,DBRecord>l_teacherCalenderArchMap=null;

                               try{ 

                                   l_teacherCalenderArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_CALENDER_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_teacherCalenderArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_teacherCalenderArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "TeacherPayrollArchival":
                            Map<String,DBRecord>l_teacherPayrollArchMap=null;

                               try{ 

                                   l_teacherPayrollArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_PAYROLL_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_teacherPayrollArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_teacherPayrollArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          case "StudentPaymentArchival":
                            Map<String,DBRecord>l_studentPaymentArchMap=null;

                               try{ 

                                   l_studentPaymentArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_PAYMENT_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_studentPaymentArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_studentPaymentArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "InstitutePaymentArchival":
                            Map<String,DBRecord>l_institutePaymentArchMap=null;

                               try{ 

                                   l_institutePaymentArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_PAYMENT_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_institutePaymentArchMap.values().stream().filter(rec->rec.getRecord().get( 1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_institutePaymentArchMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "TeacherAttendanceArchival":
                            Map<String,DBRecord>l_teacherAttendanceArchMap=null;

                               try{ 

                                   l_teacherAttendanceArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_ATTENDANCE_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_teacherAttendanceArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_teacherAttendanceArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "TeacherTimeTableArchival":
                            Map<String,DBRecord>l_teacherTimeTableArchMap=null;

                               try{ 

                                   l_teacherTimeTableArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_TIME_TABLE_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_teacherTimeTableArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_teacherTimeTableArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                          case "StudentProfileArchival":
                            Map<String,DBRecord>l_studentProfileArchMap=null;

                               try{ 

                                   l_studentProfileArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_PROFILE_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_studentProfileArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_studentProfileArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                          
                           case "TeacherProfileArchival":
                            Map<String,DBRecord>l_teacherProfileArchMap=null;

                               try{ 

                                   l_teacherProfileArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_PROFILE_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("5", endTime);
                                     column_to_Update.put("6", "F");
                                     updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_teacherProfileArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       int failedRecords=  l_teacherProfileArchMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("5", endTime);
                                       column_to_Update.put("6", "F");
                                       column_to_Update.put("7", Integer.toString(successRecords));
                                       column_to_Update.put("8", Integer.toString(failedRecords));
                                   }   
                          break;
                      }
                   
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "BATCH_STATUS", l_pkey, column_to_Update,session); 
                   tc.commit(session, dbSession);
                   
                   updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,e,l_pkey,inject,session,dbSession);
                  
                   
            dbg("end of batchErrorHandler");
    tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
     
    private void updateBatchErrorTable(String p_businessDate,String p_instituteID,String p_batchName,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            dbg("inside update batch error table");
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            ITransactionControlService tc=inject.getTransactionControlService();
            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            BusinessService bs=inject.getBusinessService(session);
            String currentTime=bs.getCurrentDateTime();
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
            String[] l_errorPkey={p_instituteID,p_batchName,p_businessDate};
            
            
              boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "BATCH_STATUS_ERROR", l_errorPkey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "BATCH_STATUS_ERROR", l_errorPkey, column_to_Update,session); 
                   }else{
                       
                       dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 106,p_instituteID,p_batchName,p_businessDate,l_replacedException);
                   
                   }
            
            tc.commit(session, dbSession);
            dbg("end update batch error table");
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
      }catch(BSProcessingException ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
        
    }  
     
      public void batchSucessHandler(String p_instituteID,String l_businessDate,String p_batchName,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside batchSucessHandler");
            dbg("p_batchName"+p_batchName);
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            tc=inject.getTransactionControlService();
            BusinessService bs=inject.getBusinessService(session);
            column_to_Update=new HashMap();
            String endTime=bs.getCurrentDateTime();
            int maxSequence=getBatchMaxSequence(l_businessDate,p_instituteID,p_batchName,inject,session,dbSession);
            String[] l_pkey={p_instituteID,p_batchName,l_businessDate,Integer.toString(maxSequence)};
            boolean exceptionRaised=false; 
            switch(p_batchName){
                
                case "Assignment":
            
                   Map<String,DBRecord>l_assignmentMap=null;
                        try{ 

                               l_assignmentMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_assignmentMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_assignmentMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "UnAuth":
            
    

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(0));
                           column_to_Update.put("8", Integer.toString(0));
                   break;
                   
                   
                  case "ECircular":
            
                   Map<String,DBRecord>l_eCircularMap=null;
                        try{ 

                               l_eCircularMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "E_CIRCULAR_EOD_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_eCircularMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_eCircularMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   case "OtherActivity":
            
                   Map<String,DBRecord>l_OtherActvityMap=null;
                        try{ 

                               l_OtherActvityMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "OTHER_ACTIVITY_EOD_STATUS", session, dbSession);

                                 
                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                            

                           int successRecords= l_OtherActvityMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_OtherActvityMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   
                   case "FeeManagement":
            
                     Map<String,DBRecord>l_FeeMap=null;
                        try{ 

                               l_FeeMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_EOD_STATUS", session, dbSession);

                                 
                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                            

                           int successRecords= l_FeeMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_FeeMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "FeeNotification":
            
                     Map<String,DBRecord>l_FeeNotificationMap=null;
                        try{ 

                               l_FeeNotificationMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_NOTIFICATION_EOD_STATUS", session, dbSession);

                                 
                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                            

                           int successRecords= l_FeeNotificationMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_FeeNotificationMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   case "EventNotification":
            
                     Map<String,DBRecord>l_EventNotificationMap=null;
                        try{ 

                               l_EventNotificationMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EVENT_NOTIFICATION_EOD_STATUS", session, dbSession);

                                 
                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                            

                           int successRecords= l_EventNotificationMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_EventNotificationMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   case "Notification":
            
                   Map<String,DBRecord>l_notificationMap=null;
                        try{ 

                               l_notificationMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "NOTIFICATION_EOD_STATUS", session, dbSession);

                                 
                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                            

                           int successRecords= l_notificationMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_notificationMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   
                   case "TimeTable":
            
                   Map<String,DBRecord>l_timeTableMap=null;
                        try{ 

                               l_timeTableMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TIMETABLE_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_timeTableMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_timeTableMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "Exam":
            
                   Map<String,DBRecord>l_examMap=null;
                        try{ 

                               l_examMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "EXAM_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_examMap.values().stream().filter(rec->rec.getRecord().get(4).trim().equals(l_businessDate)&&rec.getRecord().get(5).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_examMap.values().stream().filter(rec->rec.getRecord().get(4).trim().equals(l_businessDate)&&rec.getRecord().get(5).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "Mark":
            
                   Map<String,DBRecord>l_markMap=null;
                        try{ 

                               l_markMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "MARK_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_markMap.values().stream().filter(rec->rec.getRecord().get(5).trim().equals(l_businessDate)&&rec.getRecord().get(6).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_markMap.values().stream().filter(rec->rec.getRecord().get(5).trim().equals(l_businessDate)&&rec.getRecord().get(6).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "Attendance":
            
                   Map<String,DBRecord>l_attendanceMap=null;
                        try{ 

                               l_attendanceMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ATTENDANCE_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_attendanceMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_attendanceMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "StudentAssignmentArchival":
            
                   Map<String,DBRecord>l_studentAssignmentArchivalMap=null;
                        try{ 

                               l_studentAssignmentArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ASSIGNMENT_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_studentAssignmentArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_studentAssignmentArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "InstituteAssignmentArchival":
            
                   Map<String,DBRecord>l_instituteAssignmentArchivalMap=null;
                        try{ 

                               l_instituteAssignmentArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_ASSIGNMENT_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_instituteAssignmentArchivalMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_instituteAssignmentArchivalMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   case "StudentOtherActivityArchival":
            
                   Map<String,DBRecord>l_studentOtherActivityArchivalMap=null;
                        try{ 

                               l_studentOtherActivityArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_OTHER_ACTIVITY_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_studentOtherActivityArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_studentOtherActivityArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "InstituteOtherActivityArchival":
            
                   Map<String,DBRecord>l_instituteOtherActivityArchivalMap=null;
                        try{ 

                               l_instituteOtherActivityArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_OTHER_ACTIVITY_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_instituteOtherActivityArchivalMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_instituteOtherActivityArchivalMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                    case "StudentFeeArchival":
            
                   Map<String,DBRecord>l_studentFeeArchivalMap=null;
                        try{ 

                               l_studentFeeArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_FEE_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_studentFeeArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_studentFeeArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "InstituteFeeArchival":
            
                   Map<String,DBRecord>l_instituteFeeArchivalMap=null;
                        try{ 

                               l_instituteFeeArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_FEE_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_instituteFeeArchivalMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_instituteFeeArchivalMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                    case "StudentNotificationArchival":
            
                   Map<String,DBRecord>l_studentNotificationArchivalMap=null;
                        try{ 

                               l_studentNotificationArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_NOTIFICATION_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_studentNotificationArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_studentNotificationArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "InstituteNotificationArchival":
            
                   Map<String,DBRecord>l_instituteNotificationArchivalMap=null;
                        try{ 

                               l_instituteNotificationArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_NOTIFICATION_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_instituteNotificationArchivalMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_instituteNotificationArchivalMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "StudentMarkArchival":
            
                   Map<String,DBRecord>l_studentMarkArchivalMap=null;
                        try{ 

                               l_studentMarkArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_MARK_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_studentMarkArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_studentMarkArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "ClassMarkArchival":
            
                   Map<String,DBRecord>l_classMarkArchivalMap=null;
                        try{ 

                               l_classMarkArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_MARK_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_classMarkArchivalMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_classMarkArchivalMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "StudentExamArchival":
            
                   Map<String,DBRecord>l_studentExamArchivalMap=null;
                        try{ 

                               l_studentExamArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EXAM_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_studentExamArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_studentExamArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "ClassExamArchival":
            
                   Map<String,DBRecord>l_classExamArchivalMap=null;
                        try{ 

                               l_classExamArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_EXAM_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_classExamArchivalMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_classExamArchivalMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   case "StudentTimeTableArchival":
            
                   Map<String,DBRecord>l_studentTimeTableArchivalMap=null;
                        try{ 

                               l_studentTimeTableArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_TIME_TABLE_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_studentTimeTableArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_studentTimeTableArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "ClassTimeTableArchival":
            
                   Map<String,DBRecord>l_classTimeTableArchivalMap=null;
                        try{ 

                               l_classTimeTableArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_TIME_TABLE_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_classTimeTableArchivalMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_classTimeTableArchivalMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                    case "StudentAttendanceArchival":
            
                   Map<String,DBRecord>l_studentAttendanceArchivalMap=null;
                        try{ 

                               l_studentAttendanceArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ATTENDANCE_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_studentAttendanceArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_studentAttendanceArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "ClassAttendanceArchival":
            
                   Map<String,DBRecord>l_classAttendanceArchivalMap=null;
                        try{ 

                               l_classAttendanceArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_ATTENDANCE_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_classAttendanceArchivalMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_classAttendanceArchivalMap.values().stream().filter(rec->rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "StudentLeaveArchival":
            
                   Map<String,DBRecord>l_studentLeaveArchivalMap=null;
                        try{ 

                               l_studentLeaveArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_LEAVE_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_studentLeaveArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_studentLeaveArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   case "TeacherLeaveArchival":
            
                   Map<String,DBRecord>l_teacherLeaveArchivalMap=null;
                        try{ 

                               l_teacherLeaveArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_LEAVE_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_teacherLeaveArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_teacherLeaveArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "StudentCalenderArchival":
            
                   Map<String,DBRecord>l_studentCalenderArchivalMap=null;
                        try{ 

                               l_studentCalenderArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_CALENDER_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_studentCalenderArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_studentCalenderArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   case "TeacherCalenderArchival":
            
                   Map<String,DBRecord>l_teacherCalenderArchivalMap=null;
                        try{ 

                               l_teacherCalenderArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_CALENDER_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_teacherCalenderArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_teacherCalenderArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "TeacherPayrollArchival":
            
                   Map<String,DBRecord>l_teacherPayrollArchivalMap=null;
                        try{ 

                               l_teacherPayrollArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_PAYROLL_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_teacherPayrollArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_teacherPayrollArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "StudentPaymentArchival":
            
                   Map<String,DBRecord>l_studentPaymentArchivalMap=null;
                        try{ 

                               l_studentPaymentArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_PAYMENT_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_studentPaymentArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_studentPaymentArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "InstitutePaymentArchival":
            
                   Map<String,DBRecord>l_institutePaymentArchivalMap=null;
                        try{ 

                               l_institutePaymentArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_PAYMENT_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_institutePaymentArchivalMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_institutePaymentArchivalMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   case "TeacherAttendanceArchival":
            
                   Map<String,DBRecord>l_teacherAttendanceArchivalMap=null;
                        try{ 

                               l_teacherAttendanceArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_ATTENDANCE_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_teacherAttendanceArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_teacherAttendanceArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "TeacherTimeTableArchival":
            
                   Map<String,DBRecord>l_teacherTimeTableArchivalMap=null;
                        try{ 

                               l_teacherTimeTableArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_TIME_TABLE_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_teacherTimeTableArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_teacherTimeTableArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "StudentProfileArchival":
            
                   Map<String,DBRecord>l_studentProfileArchivalMap=null;
                        try{ 

                               l_studentProfileArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_PROFILE_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_studentProfileArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_studentProfileArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                   case "TeacherProfileArchival":
            
                   Map<String,DBRecord>l_teacherProfileArchivalMap=null;
                        try{ 

                               l_teacherProfileArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_PROFILE_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateBatchErrorTable(l_businessDate,p_instituteID,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("5", endTime);
                               column_to_Update.put("6", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_teacherProfileArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("S")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           int failedRecords=  l_teacherProfileArchivalMap.values().stream().filter(rec->rec.getRecord().get(2).trim().equals(l_businessDate)&&rec.getRecord().get(3).trim().equals("F")&&rec.getRecord().get(0).trim().equals(p_instituteID)).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("5", endTime);
                           column_to_Update.put("6", "S");
                           column_to_Update.put("7", Integer.toString(successRecords));
                           column_to_Update.put("8", Integer.toString(failedRecords));
                        }
                   break;
                } 
            
            
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "BATCH_STATUS", l_pkey, column_to_Update,session); 
            
            dbg("end of batchSucessHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    } 

   
    public void appBatchErrorHandler(String l_businessDate,Exception e,String p_batchName,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside appBatchErrorHandler");
            dbg("p_batchName"+p_batchName);
            dbg("exception"+e);
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            tc=inject.getTransactionControlService();
            BusinessService bs=inject.getBusinessService(session);
            column_to_Update=new HashMap();
            String endTime=bs.getCurrentDateTime();
            String[] l_pkey={p_batchName,l_businessDate};
            
            try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            boolean exceptionRaised=false; 
            switch(p_batchName){
                
                case "UserProfileArchival":
                            Map<String,DBRecord>l_userProfileArchMap=null;

                               try{ 

                                   l_userProfileArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "USER_PROFILE_ARCH_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("4", endTime);
                                     column_to_Update.put("5", "F");
                                     updateAppBatchErrorTable(l_businessDate,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_userProfileArchMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("S")).collect(Collectors.toList()).size();
                                       int failedRecords=  l_userProfileArchMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("F")).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("4", endTime);
                                       column_to_Update.put("5", "F");
                                       column_to_Update.put("6", Integer.toString(successRecords));
                                       column_to_Update.put("7", Integer.toString(failedRecords));
                                   }   
                          break;
                       
                          case "Defragmentation":
                            Map<String,DBRecord>l_defragmentationArchMap=null;

                               try{ 

                                   l_defragmentationArchMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "DEFRAGMENTATION_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("4", endTime);
                                     column_to_Update.put("5", "F");
                                     updateAppBatchErrorTable(l_businessDate,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_defragmentationArchMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("S")).collect(Collectors.toList()).size();
                                       int failedRecords=  l_defragmentationArchMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("F")).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("4", endTime);
                                       column_to_Update.put("5", "F");
                                       column_to_Update.put("6", Integer.toString(successRecords));
                                       column_to_Update.put("7", Integer.toString(failedRecords));
                                   }   
                          break;
                          case "ArchivalRecovery":
                            Map<String,DBRecord>l_archivalRecoveryMap=null;

                               try{ 

                                   l_archivalRecoveryMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ARCHIVAL_RECOVERY_BATCH_STATUS", session, dbSession);

                               }catch(Exception exe){
                                     exceptionRaised=true;
                                     column_to_Update.put("4", endTime);
                                     column_to_Update.put("5", "F");
                                     updateAppBatchErrorTable(l_businessDate,p_batchName,exe,l_pkey,inject,session,dbSession);
                               }
                                   if(!exceptionRaised){
                                       int successRecords= l_archivalRecoveryMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals("S")).collect(Collectors.toList()).size();
                                       int failedRecords=  l_archivalRecoveryMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals("F")).collect(Collectors.toList()).size();
                                       dbg("successRecords"+successRecords);
                                       dbg("failedRecords"+failedRecords);
                                       dbg("end time"+endTime);
                                       column_to_Update.put("4", endTime);
                                       column_to_Update.put("5", "F");
                                       column_to_Update.put("6", Integer.toString(successRecords));
                                       column_to_Update.put("7", Integer.toString(failedRecords));
                                   }   
                          break;
                      }
                   
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "APP_BATCH_STATUS", l_pkey, column_to_Update,session); 
                   updateAppBatchErrorTable(l_businessDate,p_batchName,e,l_pkey,inject,session,dbSession);
                  
                   
            dbg("end of appBatchErrorHandler");
    tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
     
    private void updateAppBatchErrorTable(String p_businessDate,String p_batchName,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            dbg("inside updateAppBatchErrorTable");
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
              boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "APP_BATCH_STATUS_ERROR", l_pkey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                       column_to_Update=new HashMap();
                       column_to_Update.put("3", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "APP_BATCH_STATUS_ERROR", l_pkey, column_to_Update,session); 
                   }else{
                       
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 241,p_batchName,p_businessDate,l_replacedException);
                   
                   }
            
            
            dbg("end updateAppBatchErrorTable");
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
      }catch(BSProcessingException ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
        
    }  
     
      public void appBatchSucessHandler(String l_businessDate,String p_batchName,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside appBatchSucessHandler");
            dbg("p_batchName"+p_batchName);
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            tc=inject.getTransactionControlService();
            BusinessService bs=inject.getBusinessService(session);
            column_to_Update=new HashMap();
            String endTime=bs.getCurrentDateTime();
            String[] l_pkey={p_batchName,l_businessDate};
            boolean exceptionRaised=false; 
            switch(p_batchName){
                   
                   case "UserProfileArchival":
            
                   Map<String,DBRecord>l_userProfileArchivalMap=null;
                        try{ 

                               l_userProfileArchivalMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "USER_PROFILE_ARCH_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateAppBatchErrorTable(l_businessDate,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("4", endTime);
                               column_to_Update.put("5", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_userProfileArchivalMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("S")).collect(Collectors.toList()).size();
                           int failedRecords=  l_userProfileArchivalMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("F")).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("4", endTime);
                           column_to_Update.put("5", "S");
                           column_to_Update.put("6", Integer.toString(successRecords));
                           column_to_Update.put("7", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "Defragmentation":
            
                   Map<String,DBRecord>l_defragmentationMap=null;
                        try{ 

                               l_defragmentationMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "DEFRAGMENTATION_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateAppBatchErrorTable(l_businessDate,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("4", endTime);
                               column_to_Update.put("5", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_defragmentationMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("S")).collect(Collectors.toList()).size();
                           int failedRecords=  l_defragmentationMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals(l_businessDate)&&rec.getRecord().get(2).trim().equals("F")).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("4", endTime);
                           column_to_Update.put("5", "S");
                           column_to_Update.put("6", Integer.toString(successRecords));
                           column_to_Update.put("7", Integer.toString(failedRecords));
                        }
                   break;
                   
                   case "ArchivalRecovery":
            
                   Map<String,DBRecord>l_archivalRecoveryMap=null;
                        try{ 

                               l_archivalRecoveryMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "DEFRAGMENTATION_BATCH_STATUS", session, dbSession);

                           }catch(Exception exe){
                               exceptionRaised=true;
                               updateAppBatchErrorTable(l_businessDate,p_batchName,exe,l_pkey,inject,session,dbSession);
                               column_to_Update.put("4", endTime);
                               column_to_Update.put("5", "F");
                           }
                        if(!exceptionRaised){
                           int successRecords= l_archivalRecoveryMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals("S")).collect(Collectors.toList()).size();
                           int failedRecords=  l_archivalRecoveryMap.values().stream().filter(rec->rec.getRecord().get(1).trim().equals("F")).collect(Collectors.toList()).size();
                           dbg("successRecords"+successRecords);
                           dbg("failedRecords"+failedRecords);
                           dbg("end time"+endTime);

                           column_to_Update.put("4", endTime);
                           column_to_Update.put("5", "S");
                           column_to_Update.put("6", Integer.toString(successRecords));
                           column_to_Update.put("7", Integer.toString(failedRecords));
                        }
                   break;
                } 
            
            
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "APP_BATCH_STATUS", l_pkey, column_to_Update,session); 
            
            dbg("end of appBatchSucessHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    } 
    
//    public void assignmentProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_assignmentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        ITransactionControlService tc=null;
//        try{
//            dbg("inside assignmentProcessingErrorHandler");
//            dbg("exception"+e);
//            tc=inject.getTransactionControlService();
//            Map<String,String>column_to_Update=new HashMap();
//            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//            IDBTransactionService dbts=inject.getDBTransactionService();
//            BusinessService bs=inject.getBusinessService(session);
//            String endTime=bs.getCurrentDateTime();
//            Map<String,DBRecord>l_studentMap=null;
//            
//            
//            try{
//             tc.rollBack(session, dbSession);
//             }catch(DBProcessingException ex1){
//                 dbg(ex1);
//             }
//            
//             boolean exceptionRaised=false; 
//                try{
//            
//                     l_studentMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS", session, dbSession);
//                     
//                }catch(Exception exe){
//                     exceptionRaised=true;
//                     column_to_Update=new HashMap();
//                     column_to_Update.put("4", "F");
//                     column_to_Update.put("10", endTime);
//                     String[] l_pkey={p_instituteID,p_assignmentID,l_businessDate};
//                     dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS", l_pkey, column_to_Update,session); 
//                     updateAssignmentErrorTable(l_businessDate,p_instituteID,p_assignmentID,exe,l_pkey,inject,session,dbSession);
//                }  
//               
//                if(!exceptionRaised){
//                   
//                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_assignmentID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
//                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_assignmentID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
//                   dbg("successRecords"+successRecords);
//                   dbg("failedRecords"+failedRecords);
//                   dbg("end time"+endTime);
//
//                   
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("4", "F");
//                   column_to_Update.put("6", Integer.toString(successRecords));
//                   column_to_Update.put("7", Integer.toString(failedRecords));
//                   column_to_Update.put("10", endTime);
//                   String[] l_pkey={p_instituteID,p_assignmentID,l_businessDate};
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS", l_pkey, column_to_Update,session); 
//                   updateAssignmentErrorTable(l_businessDate,p_instituteID,p_assignmentID,e,l_pkey,inject,session,dbSession);
//                   
//                }  
//                   
//                   
//                   
//                   
//            
//            dbg("end of assignmentProcessingErrorHandler");
//    tc.commit(session, dbSession);
//    }catch(DBValidationException ex){
//         try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(Exception ex){
//           dbg(ex);
//           try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }
//        
//        
//    }
//    
//    
//     private void updateAssignmentErrorTable(String l_businessDate,String p_instituteID,String p_assignmentID,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        
//        try{
//            dbg("inside update assignment error table");
//            Map<String,String>column_to_Update;
//            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
//            e.printStackTrace(new PrintWriter(sw));
//            String exceptionAsString = sw.toString();
//            String l_replacedException=getReplacedException(exceptionAsString);
//            
//              boolean recordExistence=true;
//                   
//                   try{
//                       
//                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS_ERROR", l_pkey, session, dbSession,true);
//                       
//                   }catch(DBValidationException ex){
//                       
//                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
//                 
//			  recordExistence=false;
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
//              
//                        }else{
//
//                              throw ex;
//                        }
//                       
//                   }
//                   
//                   if(recordExistence){
//                   
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("4", l_replacedException);
//                   
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS_ERROR", l_pkey, column_to_Update,session);   
//                   }else{
//                       
//                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 109,p_instituteID,p_assignmentID,l_businessDate,l_replacedException);
//                   
//                   }
//            
//            
//            dbg("end of update batch error table");
//     }catch(DBValidationException ex){
//          throw ex;
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
//     }catch(Exception ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
//     }
//        
//        
//    }  
//    
//    
//    public void assignmentProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_assignmentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        ITransactionControlService tc=null;
//        try{
//            dbg("inside assignmentProcessingSuccessHandler");
//            tc=inject.getTransactionControlService();
//            Map<String,String>column_to_Update;
//            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//            IDBTransactionService dbts=inject.getDBTransactionService();
//            BusinessService bs=inject.getBusinessService(session);
//            String endTime=bs.getCurrentDateTime();
//            Map<String,DBRecord>l_studentMap=null;
//            
//            boolean exceptionRaised=false; 
//                try{
//            
//                     l_studentMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS", session, dbSession);
//                     
//                }catch(Exception exe){
//                     exceptionRaised=true;
//                     column_to_Update=new HashMap();
//                     column_to_Update.put("4", "F");
//                     column_to_Update.put("10", endTime);
//                     String[] l_pkey={p_instituteID,p_assignmentID,l_businessDate};
//                     dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS", l_pkey, column_to_Update,session); 
//                     updateAssignmentErrorTable(l_businessDate,p_instituteID,p_assignmentID,exe,l_pkey,inject,session,dbSession);
//                }
//            
//             if(!exceptionRaised) {  
//                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_assignmentID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
//                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_assignmentID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
//                   dbg("successRecords"+successRecords);
//                   dbg("failedRecords"+failedRecords);
//                   dbg("end time"+endTime);
//          
//                   
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("4", "S");
//                   column_to_Update.put("6", Integer.toString(successRecords));
//                   column_to_Update.put("7", Integer.toString(failedRecords));
//                   column_to_Update.put("10", endTime);
//                   String[] l_pkey={p_instituteID,p_assignmentID,l_businessDate};
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS", l_pkey, column_to_Update,session);  
//             }
//            dbg("end of assignmentProcessingSuccessHandler");
//     tc.commit(session, dbSession);
//    }catch(DBValidationException ex){
//         try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(Exception ex){
//           dbg(ex);
//           try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }
//        
//        
//    }
//    
//     public void studentAssignmentProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_assignmentID,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        ITransactionControlService tc=null;
//        try{
//            dbg("inside studentAssignmentProcessingSuccessHandler");
//            tc=inject.getTransactionControlService();
//            Map<String,String>column_to_Update;
//            IDBTransactionService dbts=inject.getDBTransactionService();
//            BusinessService bs=inject.getBusinessService(session);
//            String endTime=bs.getCurrentDateTime();
//            dbg("end time"+endTime);
//            
//            
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("5", "S");
//                   column_to_Update.put("8", endTime);
//                   String[] l_primaryKey={p_instituteID,p_assignmentID,l_studentID,l_businessDate};
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS", l_primaryKey, column_to_Update,session);
//            
//            dbg("end of studentAssignmentProcessingSuccessHandler");
//     
//     try{       
//            
//     tc.commit(session, dbSession);
//     
//     }catch(Exception ex){
//         dbg(ex);
//         try{
//          tc.rollBack(session, dbSession);
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("5", "F");
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS", l_primaryKey, column_to_Update,session);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }
//     
//     
//    }catch(DBValidationException ex){
//         try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(Exception ex){
//           dbg(ex);
//           try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }
//        
//        
//    }
//    
//    public void studentAssignmentProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_assignmentID,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        ITransactionControlService tc=null;
//        try{
//            dbg("inside studentAssignmentProcessingErrorHandler");
//            dbg("exception"+e);
//            dbg("p_instituteID"+p_instituteID);
//            dbg("l_businessDate"+l_businessDate);
//            dbg("p_assignmentID"+p_assignmentID);
//            dbg("l_studentID"+l_studentID);
//            
//            tc=inject.getTransactionControlService();
//            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//            Map<String,String>column_to_Update;
//            IDBTransactionService dbts=inject.getDBTransactionService();
//            BusinessService bs=inject.getBusinessService(session);
//            String endTime=bs.getCurrentDateTime();
//            dbg("end time"+endTime);
//            
//            StringWriter sw = new StringWriter();
//            e.printStackTrace(new PrintWriter(sw));
//            String exceptionAsString = sw.toString();
//            String l_replacedException=getReplacedException(exceptionAsString);
//            
//             try{
//             tc.rollBack(session, dbSession);
//             }catch(DBProcessingException ex1){
//                 dbg(ex1);
//             }
//            
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("5", "F");
//                   column_to_Update.put("8", endTime);
//                   String[] l_primaryKey={p_instituteID,p_assignmentID,l_studentID,l_businessDate};
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS", l_primaryKey, column_to_Update,session);
//                   
//                   boolean recordExistence=true;
//                   
//                   try{
//                       
//                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS_ERROR", l_primaryKey, session, dbSession,true);
//                       
//                   }catch(DBValidationException ex){
//                       
//                      if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
//                 
//			  recordExistence=false;
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
//              
//                        }else{
//
//                              throw ex;
//                        }
//                       
//                   }
//                   
//                   if(recordExistence){
//                   
//                       column_to_Update=new HashMap();
//                       column_to_Update.put("5", l_replacedException);
//                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS_ERROR", l_primaryKey, column_to_Update,session);
//                   }else{
//                       
//                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 110, p_instituteID,p_assignmentID,l_studentID,l_businessDate,l_replacedException);
//                   
//                   }
//                   
//            
//            dbg("inside studentAssignmentProcessingErrorHandler");
//     tc.commit(session, dbSession);
//    }catch(DBValidationException ex){
//         try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(Exception ex){
//           dbg(ex);
//           try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }
//        
//        
//    }
    public void assignmentProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_assignmentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside assignmentProcessingErrorHandler");
            dbg("exception"+e);
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update=new HashMap();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            
            try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
             boolean exceptionRaised=false; 
                try{
            
                     l_studentMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Assignment"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_assignmentID, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS", session, dbSession);
                     
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("4", "F");
                     column_to_Update.put("10", endTime);
                     String[] l_pkey={p_instituteID,p_assignmentID,l_businessDate};
                     dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS", l_pkey, column_to_Update,session); 
                     tc.commit(session, dbSession);
                     updateAssignmentErrorTable(l_businessDate,p_instituteID,p_assignmentID,exe,l_pkey,inject,session,dbSession);
                }  
               
                if(!exceptionRaised){
                   
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_assignmentID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_assignmentID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);

                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   column_to_Update.put("10", endTime);
                   String[] l_pkey={p_instituteID,p_assignmentID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS", l_pkey, column_to_Update,session); 
                   tc.commit(session, dbSession);
                   updateAssignmentErrorTable(l_businessDate,p_instituteID,p_assignmentID,e,l_pkey,inject,session,dbSession);
                   
                }  
                   
                   
                   
                   
            
            dbg("end of assignmentProcessingErrorHandler");
    tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
     private void updateAssignmentErrorTable(String l_businessDate,String p_instituteID,String p_assignmentID,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            dbg("inside update assignment error table");
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            ITransactionControlService tc=inject.getTransactionControlService();
            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            BusinessService bs=inject.getBusinessService(session);
            String currentTime=bs.getCurrentDateTime();
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
              boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS_ERROR", l_pkey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", l_replacedException);
                   
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS_ERROR", l_pkey, column_to_Update,session);   
                   }else{
                       
                       dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 109,p_instituteID,p_assignmentID,l_businessDate,l_replacedException);
                   
                   }
            
            tc.commit(session, dbSession);
            dbg("end of update assignment batch error table");
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
      }catch(BSProcessingException ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
        
    }  
    
    
    public void assignmentProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_assignmentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside assignmentProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            boolean exceptionRaised=false; 
                try{
            
                     l_studentMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Assignment"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_assignmentID, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS", session, dbSession);
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("4", "F");
                     column_to_Update.put("10", endTime);
                     String[] l_pkey={p_instituteID,p_assignmentID,l_businessDate};
                     dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS", l_pkey, column_to_Update,session); 
                     tc.commit(session, dbSession);
                     updateAssignmentErrorTable(l_businessDate,p_instituteID,p_assignmentID,exe,l_pkey,inject,session,dbSession);
                }
            
             if(!exceptionRaised) {  
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_assignmentID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_assignmentID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);
          
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   column_to_Update.put("10", endTime);
                   String[] l_pkey={p_instituteID,p_assignmentID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS", l_pkey, column_to_Update,session);  
             }
            dbg("end of assignmentProcessingSuccessHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
     public void studentAssignmentProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_assignmentID,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentAssignmentProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);

            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "S");
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_assignmentID,l_studentID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Assignment"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_assignmentID, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentAssignmentProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Assignment"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_assignmentID, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS", l_primaryKey, column_to_Update,session);
                   tc.commit(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentAssignmentProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_assignmentID,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentAssignmentProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("p_assignmentID"+p_assignmentID);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String currentTime=bs.getCurrentDateTime();
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_assignmentID,l_studentID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Assignment"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_assignmentID, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS", l_primaryKey, column_to_Update,session);
                   tc.commit(session, dbSession);
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Assignment"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_assignmentID, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("5", l_replacedException);
                       dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Assignment"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_assignmentID, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       
                       dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Assignment"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_assignmentID, "BATCH", 110, p_instituteID,p_assignmentID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentAssignmentProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
   public void  moveAppRecordToHistory(String p_businessDate,DBRecord appRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveAppRecordToHistory");
           ArrayList<String>appEodList=appRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_appHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
               //group by pkey
           l_appHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "APP_EOD_STATUS_HISTORY", session, dbSession,true);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_appHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(7).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 103, appEodList.get(0).trim(),appEodList.get(1).trim(),appEodList.get(2).trim(),appEodList.get(3).trim(),appEodList.get(4).trim(),appEodList.get(5).trim(),appEodList.get(6).trim(),Integer.toString(sequenceNo));
           
           
           dbg("end of move app record to history");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
          throw new BSProcessingException(ex.toString());
     }
       
       
       
   }
   
   public void  moveInstituteRecordToHistory(String p_instituteID,String p_businessDate,DBRecord instituteRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           
           dbg("inside moveInstituteRecordToHistory");
           ArrayList<String>instituteEodList=instituteRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_instituteHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           
           
           try{
           
           l_instituteHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "INSTITUTE_EOD_STATUS_HISTORY", session, dbSession,true);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_instituteHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           
           dbg("sequenceNo"+sequenceNo);
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 102, instituteEodList.get(0).trim(),instituteEodList.get(1).trim(),instituteEodList.get(2).trim(),instituteEodList.get(3).trim(),instituteEodList.get(4).trim(),instituteEodList.get(5).trim(),instituteEodList.get(6).trim(),instituteEodList.get(7).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveInstituteRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   }
    
    public void  moveBatchRecordToHistory(String p_instituteID,String p_batchName,String p_businessDate,DBRecord batchRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveBatchRecordToHistory");
           ArrayList<String>batchEodList=batchRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_batchHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_batchHistoryMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "BATCH_STATUS_HISTORY", session, dbSession,true);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_batchHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_batchName)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(9).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           
           dbg("sequenceNo"+sequenceNo);
           
           dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+ "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 101, batchEodList.get(0).trim(),batchEodList.get(1).trim(),batchEodList.get(2).trim(),batchEodList.get(3).trim(),batchEodList.get(4).trim(),batchEodList.get(5).trim(),batchEodList.get(6).trim(),batchEodList.get(7).trim(),batchEodList.get(8).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveBatchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
         throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   }
    
    public void  moveAppBatchRecordToHistory(String p_batchName,String p_businessDate,DBRecord batchRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveAppBatchRecordToHistory");
           ArrayList<String>batchEodList=batchRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_batchHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_batchHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "APP_BATCH_STATUS_HISTORY", session, dbSession,true);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_batchHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_batchName)&&rec.getRecord().get(1).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           
           dbg("sequenceNo"+sequenceNo);
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 240, batchEodList.get(0).trim(),batchEodList.get(1).trim(),batchEodList.get(2).trim(),batchEodList.get(3).trim(),batchEodList.get(4).trim(),batchEodList.get(5).trim(),batchEodList.get(6).trim(),batchEodList.get(7).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveAppBatchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
         throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   }
//    public void  moveAssignmentRecordToHistory(String p_instituteID,String p_assignmentID,String p_businessDate,DBRecord assignmentRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
//       
//       try{
//           
//           dbg("inside moveAssignmentRecordToHistory");
//           ArrayList<String>assignmentEodList=assignmentRecord.getRecord();
//           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//           IDBTransactionService dbts=inject.getDBTransactionService();
//           Map<String,DBRecord>l_assignmentHistoryMap=null;
//           boolean recordExistence=true;
//           int sequenceNo=0;
//           
//           try{
//           
//           l_assignmentHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS_HISTORY", session, dbSession,true);
//           
//          }catch(DBValidationException ex){
//            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
//                 
//			  recordExistence=false;
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
//              
//                        }else{
//
//                              throw ex;
//                        }
//         }
//           dbg("recordExistence"+recordExistence);
//           if(recordExistence){
//               
//              int maxSequence= l_assignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_assignmentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
//              
//              sequenceNo=maxSequence+1;
//           }else{
//               sequenceNo=sequenceNo+1;
//           }
//           
//           dbg("sequenceNo"+sequenceNo);
//           
//           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 104, assignmentEodList.get(0).trim(),assignmentEodList.get(1).trim(),assignmentEodList.get(2).trim(),assignmentEodList.get(3).trim(),assignmentEodList.get(4).trim(),assignmentEodList.get(5).trim(),assignmentEodList.get(6).trim(),assignmentEodList.get(7).trim(),assignmentEodList.get(8).trim(),assignmentEodList.get(9).trim(),Integer.toString(sequenceNo));
//           
//           dbg("end of moveAssignmentRecordToHistory");
//     }catch(DBValidationException ex){
//          throw ex;
////     }catch(BSValidationException ex){
////          throw ex;     
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          throw new DBProcessingException("DBProcessingException"+ex.toString());
////      }catch(BSProcessingException ex){
////           dbg(ex);
////           throw new BSProcessingException(ex.toString());
//     }catch(Exception ex){
//           dbg(ex);
//          throw new BSProcessingException(ex.toString());
//     }
//       
//   }
//    public void  moveECircularRecordToHistory(String p_instituteID,String p_eCircularID,String p_businessDate,DBRecord eCircularRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
//       
//       try{
//           
//           dbg("inside moveeCircularRecordToHistory");
//           ArrayList<String>eCircularEodList=eCircularRecord.getRecord();
//           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//           IDBTransactionService dbts=inject.getDBTransactionService();
//           Map<String,DBRecord>l_eCircularHistoryMap=null;
//           boolean recordExistence=true;
//           int sequenceNo=0;
//           
//           try{
//           
//           l_eCircularHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "E_CIRCULAR_EOD_STATUS_HISTORY", session, dbSession,true);
//           
//          }catch(DBValidationException ex){
//            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
//                 
//			  recordExistence=false;
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
//              
//                        }else{
//
//                              throw ex;
//                        }
//         }
//           dbg("recordExistence"+recordExistence);
//           if(recordExistence){
//               
//              int maxSequence= l_eCircularHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_eCircularID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
//              
//              sequenceNo=maxSequence+1;
//           }else{
//               sequenceNo=sequenceNo+1;
//           }
//           
//           dbg("sequenceNo"+sequenceNo);
//           
//           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 293, eCircularEodList.get(0).trim(),eCircularEodList.get(1).trim(),eCircularEodList.get(2).trim(),eCircularEodList.get(3).trim(),eCircularEodList.get(4).trim(),eCircularEodList.get(5).trim(),eCircularEodList.get(6).trim(),eCircularEodList.get(7).trim(),eCircularEodList.get(8).trim(),eCircularEodList.get(9).trim(),Integer.toString(sequenceNo));
//           
//           dbg("end of moveeCircularRecordToHistory");
//     }catch(DBValidationException ex){
//          throw ex;
////     }catch(BSValidationException ex){
////          throw ex;     
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          throw new DBProcessingException("DBProcessingException"+ex.toString());
////      }catch(BSProcessingException ex){
////           dbg(ex);
////           throw new BSProcessingException(ex.toString());
//     }catch(Exception ex){
//           dbg(ex);
//          throw new BSProcessingException(ex.toString());
//     }
//       
//   }
    
    
//    public void  moveECircularRecordToHistory(String p_instituteID,String p_eCircularID,String p_businessDate,DBRecord eCircularRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
//       
//       try{
//           
//           dbg("inside moveECircularRecordToHistory");
//           ArrayList<String>eCircularEodList=eCircularRecord.getRecord();
//           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//           IDBTransactionService dbts=inject.getDBTransactionService();
//           Map<String,DBRecord>l_eCircularHistoryMap=null;
//           boolean recordExistence=true;
//           int sequenceNo=0;
//           
//           try{
//           
//           l_eCircularHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "E_CIRCULAR_EOD_STATUS_HISTORY", session, dbSession,true);
//           
//          }catch(DBValidationException ex){
//            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
//                 
//			  recordExistence=false;
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
//              
//                        }else{
//
//                              throw ex;
//                        }
//         }
//           dbg("recordExistence"+recordExistence);
//           if(recordExistence){
//               
//               
//              List<DBRecord>filteredList=l_eCircularHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_eCircularID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).collect(Collectors.toList());
//               
//              int maxSequence=0; 
//              
//              if(!filteredList.isEmpty()){
//              
//                  maxSequence= l_eCircularHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_eCircularID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
//              
//                 
//              }else{
//                  
//                  maxSequence=0;
//              }
//              
//              
//              sequenceNo=maxSequence+1;
//           }else{
//               sequenceNo=sequenceNo+1;
//           }
//           
//           dbg("sequenceNo"+sequenceNo);
//           
//           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 293, eCircularEodList.get(0).trim(),eCircularEodList.get(1).trim(),eCircularEodList.get(2).trim(),eCircularEodList.get(3).trim(),eCircularEodList.get(4).trim(),eCircularEodList.get(5).trim(),eCircularEodList.get(6).trim(),eCircularEodList.get(7).trim(),eCircularEodList.get(8).trim(),eCircularEodList.get(9).trim(),Integer.toString(sequenceNo));
//           
//           dbg("end of moveECircularRecordToHistory");
//     }catch(DBValidationException ex){
//          throw ex;
////     }catch(BSValidationException ex){
////          throw ex;     
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          throw new DBProcessingException("DBProcessingException"+ex.toString());
////      }catch(BSProcessingException ex){
////           dbg(ex);
////           throw new BSProcessingException(ex.toString());
//     }catch(Exception ex){
//           dbg(ex);
//          throw new BSProcessingException(ex.toString());
//     }
//       
//   }
//    
    
    public void  moveECircularRecordToHistory(String p_instituteID,String p_eCircularID,String p_businessDate,DBRecord eCircularRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           
           dbg("inside moveFeeRecordToHistory");
           ArrayList<String>eCircularEodList=eCircularRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_assignmentHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_assignmentHistoryMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "E_CIRCULAR_EOD_STATUS_HISTORY", session, dbSession,true);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_assignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_eCircularID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           
           dbg("sequenceNo"+sequenceNo);
           
           dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+ "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 293, eCircularEodList.get(0).trim(),eCircularEodList.get(1).trim(),eCircularEodList.get(2).trim(),eCircularEodList.get(3).trim(),eCircularEodList.get(4).trim(),eCircularEodList.get(5).trim(),eCircularEodList.get(6).trim(),eCircularEodList.get(7).trim(),eCircularEodList.get(8).trim(),eCircularEodList.get(9).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveFeeRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
          throw new BSProcessingException(ex.toString());
     }
       
   }
    
    
//    public void  moveOtherActivityRecordToHistory(String p_instituteID,String p_activityID,String p_businessDate,DBRecord otherActivityRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
//       
//       try{
//           
//           dbg("inside moveOtherActivityRecordToHistory");
//           ArrayList<String>otherActivityEodList=otherActivityRecord.getRecord();
//           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//           IDBTransactionService dbts=inject.getDBTransactionService();
//           Map<String,DBRecord>l_assignmentHistoryMap=null;
//           boolean recordExistence=true;
//           int sequenceNo=0;
//           
//           try{
//           
//           l_assignmentHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "OTHER_ACTIVITY_EOD_STATUS_HISTORY", session, dbSession,true);
//           
//          }catch(DBValidationException ex){
//            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
//                 
//			  recordExistence=false;
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
//              
//                        }else{
//
//                              throw ex;
//                        }
//         }
//           dbg("recordExistence"+recordExistence);
//           if(recordExistence){
//               
//              int maxSequence= l_assignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_activityID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
//              
//              sequenceNo=maxSequence+1;
//           }else{
//               sequenceNo=sequenceNo+1;
//           }
//           
//           dbg("sequenceNo"+sequenceNo);
//           
//           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 112, otherActivityEodList.get(0).trim(),otherActivityEodList.get(1).trim(),otherActivityEodList.get(2).trim(),otherActivityEodList.get(3).trim(),otherActivityEodList.get(4).trim(),otherActivityEodList.get(5).trim(),otherActivityEodList.get(6).trim(),otherActivityEodList.get(7).trim(),otherActivityEodList.get(8).trim(),otherActivityEodList.get(9).trim(),Integer.toString(sequenceNo));
//           
//           dbg("end of moveOtherActivityRecordToHistory");
//     }catch(DBValidationException ex){
//          throw ex;
////     }catch(BSValidationException ex){
////          throw ex;     
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          throw new DBProcessingException("DBProcessingException"+ex.toString());
////      }catch(BSProcessingException ex){
////           dbg(ex);
////           throw new BSProcessingException(ex.toString());
//     }catch(Exception ex){
//           dbg(ex);
//          throw new BSProcessingException(ex.toString());
//     }
//       
//   }
    public void  moveOtherActivityRecordToHistory(String p_instituteID,String p_otherActivityID,String p_businessDate,DBRecord otherActivityRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           
           dbg("inside moveOtherActivityRecordToHistory");
           ArrayList<String>otherActivityEodList=otherActivityRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_assignmentHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_assignmentHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "OTHER_ACTIVITY_EOD_STATUS_HISTORY", session, dbSession,true);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
               
              List<DBRecord>filteredList=l_assignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_otherActivityID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).collect(Collectors.toList());
               
              int maxSequence=0; 
              
              if(!filteredList.isEmpty()){
              
                  maxSequence= l_assignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_otherActivityID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
              
                 
              }else{
                  
                  maxSequence=0;
              }
              
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           
           dbg("sequenceNo"+sequenceNo);
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 112, otherActivityEodList.get(0).trim(),otherActivityEodList.get(1).trim(),otherActivityEodList.get(2).trim(),otherActivityEodList.get(3).trim(),otherActivityEodList.get(4).trim(),otherActivityEodList.get(5).trim(),otherActivityEodList.get(6).trim(),otherActivityEodList.get(7).trim(),otherActivityEodList.get(8).trim(),otherActivityEodList.get(9).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveOtherActivityRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
          throw new BSProcessingException(ex.toString());
     }
       
   }
    public void  moveAssignmentRecordToHistory(String p_instituteID,String p_assignmentID,String p_businessDate,DBRecord assignmentRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           
           dbg("inside moveAssignmentRecordToHistory");
           ArrayList<String>assignmentEodList=assignmentRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_assignmentHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_assignmentHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS_HISTORY", session, dbSession,true);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
               
              List<DBRecord>filteredList=l_assignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_assignmentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).collect(Collectors.toList());
               
              int maxSequence=0; 
              
              if(!filteredList.isEmpty()){
              
                  maxSequence= l_assignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_assignmentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
              
                 
              }else{
                  
                  maxSequence=0;
              }
              
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           
           dbg("sequenceNo"+sequenceNo);
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 104, assignmentEodList.get(0).trim(),assignmentEodList.get(1).trim(),assignmentEodList.get(2).trim(),assignmentEodList.get(3).trim(),assignmentEodList.get(4).trim(),assignmentEodList.get(5).trim(),assignmentEodList.get(6).trim(),assignmentEodList.get(7).trim(),assignmentEodList.get(8).trim(),assignmentEodList.get(9).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveAssignmentRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
          throw new BSProcessingException(ex.toString());
     }
       
   }
     public void  moveFeeRecordToHistory(String p_instituteID,String p_feeID,String p_businessDate,DBRecord feeRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           
           dbg("inside moveFeeRecordToHistory");
           ArrayList<String>feeEodList=feeRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_assignmentHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_assignmentHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "FEE_EOD_STATUS_HISTORY", session, dbSession,true);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_assignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           
           dbg("sequenceNo"+sequenceNo);
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 118, feeEodList.get(0).trim(),feeEodList.get(1).trim(),feeEodList.get(2).trim(),feeEodList.get(3).trim(),feeEodList.get(4).trim(),feeEodList.get(5).trim(),feeEodList.get(6).trim(),feeEodList.get(7).trim(),feeEodList.get(8).trim(),feeEodList.get(9).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveFeeRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
          throw new BSProcessingException(ex.toString());
     }
       
   }
     public void  moveFeeNotificationToHistory(String p_instituteID,String p_feeID,String p_businessDate,DBRecord FeeNotification,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           
           dbg("inside moveFeeNotificationToHistory");
           ArrayList<String>feeEodList=FeeNotification.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_assignmentHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_assignmentHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "FEE_NOTIFICATION_EOD_STATUS_HISTORY", session, dbSession,true);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_assignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           
           dbg("sequenceNo"+sequenceNo);
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 334, feeEodList.get(0).trim(),feeEodList.get(1).trim(),feeEodList.get(2).trim(),feeEodList.get(3).trim(),feeEodList.get(4).trim(),feeEodList.get(5).trim(),feeEodList.get(6).trim(),feeEodList.get(7).trim(),feeEodList.get(8).trim(),feeEodList.get(9).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveFeeNotificationToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
          throw new BSProcessingException(ex.toString());
     }
       
   }
     
     public void  moveNotificationRecordToHistory(String p_instituteID,String p_notificationID,String p_businessDate,DBRecord notificationRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           
           dbg("inside moveFeeRecordToHistory");
           ArrayList<String>notificationEodList=notificationRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_assignmentHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_assignmentHistoryMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "NOTIFICATION_EOD_STATUS_HISTORY", session, dbSession,true);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_assignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_notificationID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           
           dbg("sequenceNo"+sequenceNo);
           
           dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+ "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 125, notificationEodList.get(0).trim(),notificationEodList.get(1).trim(),notificationEodList.get(2).trim(),notificationEodList.get(3).trim(),notificationEodList.get(4).trim(),notificationEodList.get(5).trim(),notificationEodList.get(6).trim(),notificationEodList.get(7).trim(),notificationEodList.get(8).trim(),notificationEodList.get(9).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveFeeRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
          throw new BSProcessingException(ex.toString());
     }
       
   }
     
     public void  moveClassTimeTableRecordToHistory(String p_instituteID,String p_standard,String p_section,String p_businessDate,DBRecord timeTableRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           
           dbg("inside moveClassTimeTableRecordToHistory");
           ArrayList<String>timeTableList=timeTableRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_assignmentHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_assignmentHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "TIMETABLE_BATCH_STATUS_HISTORY", session, dbSession,true);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_assignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(3).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(9).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           
           dbg("sequenceNo"+sequenceNo);
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 131, timeTableList.get(0).trim(),timeTableList.get(1).trim(),timeTableList.get(2).trim(),timeTableList.get(3).trim(),timeTableList.get(4).trim(),timeTableList.get(5).trim(),timeTableList.get(6).trim(),timeTableList.get(7).trim(),timeTableList.get(8).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveClassTimeTableRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
          throw new BSProcessingException(ex.toString());
     }
       
   }
     
   public void  moveClassExamRecordToHistory(String p_instituteID,String p_standard,String p_section,String p_exam,String p_businessDate,DBRecord timeTableRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           
           dbg("inside moveClassExamRecordToHistory");
           ArrayList<String>timeTableList=timeTableRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_assignmentHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_assignmentHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "EXAM_BATCH_STATUS_HISTORY", session, dbSession,true);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_assignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(3).trim().equals(p_exam)&&rec.getRecord().get(4).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           
           dbg("sequenceNo"+sequenceNo);
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 137, timeTableList.get(0).trim(),timeTableList.get(1).trim(),timeTableList.get(2).trim(),timeTableList.get(3).trim(),timeTableList.get(4).trim(),timeTableList.get(5).trim(),timeTableList.get(6).trim(),timeTableList.get(7).trim(),timeTableList.get(8).trim(),timeTableList.get(9).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveClassExamRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
          throw new BSProcessingException(ex.toString());
     }
       
   } 
   
   public void  moveClassMarkRecordToHistory(String p_instituteID,String p_standard,String p_section,String p_exam,String p_businessDate,DBRecord timeTableRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           
           dbg("inside moveClassMarkRecordToHistory");
           ArrayList<String>timeTableList=timeTableRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_assignmentHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_assignmentHistoryMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "MARK_BATCH_STATUS_HISTORY", session, dbSession,true);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_assignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(3).trim().equals(p_exam)&&rec.getRecord().get(4).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           
           dbg("sequenceNo"+sequenceNo);
           
           dbts.createRecord(session, "INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 143, timeTableList.get(0).trim(),timeTableList.get(1).trim(),timeTableList.get(2).trim(),timeTableList.get(3).trim(),timeTableList.get(4).trim(),timeTableList.get(5).trim(),timeTableList.get(6).trim(),timeTableList.get(7).trim(),timeTableList.get(8).trim(),timeTableList.get(9).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveClassMarkRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
          throw new BSProcessingException(ex.toString());
     }
       
   } 
   public void  moveClassAttendanceRecordToHistory(String p_instituteID,String p_standard,String p_section,String p_businessDate,DBRecord timeTableRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           
           dbg("inside moveClassAttendanceRecordToHistory");
           ArrayList<String>timeTableList=timeTableRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_assignmentHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_assignmentHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "ATTENDANCE_BATCH_STATUS_HISTORY", session, dbSession,true);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_assignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(3).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(9).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           
           dbg("sequenceNo"+sequenceNo);
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 149, timeTableList.get(0).trim(),timeTableList.get(1).trim(),timeTableList.get(2).trim(),timeTableList.get(3).trim(),timeTableList.get(4).trim(),timeTableList.get(5).trim(),timeTableList.get(6).trim(),timeTableList.get(7).trim(),timeTableList.get(8).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveClassAttendanceRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
          throw new BSProcessingException(ex.toString());
     }
       
   }
    
//   public void  moveStudentAssignmentRecordToHistory(String p_instituteID,String p_assignmentID,String p_studentID,String p_businessDate,DBRecord studentAssignmentRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
//       
//       try{
//           dbg("inside moveStudentAssignmentRecordToHistory");
//           ArrayList<String>studentAssignmentEodList=studentAssignmentRecord.getRecord();
//           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//           IDBTransactionService dbts=inject.getDBTransactionService();
//           Map<String,DBRecord>l_studentAssignmentHistoryMap=null;
//           boolean recordExistence=true;
//           int sequenceNo=0;
//           
//           try{
//           
//           l_studentAssignmentHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS_HISTORY", session, dbSession);
//           
//          }catch(DBValidationException ex){
//            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
//                 
//			  recordExistence=false;
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
//              
//                        }else{
//
//                              throw ex;
//                        }
//         }
//           dbg("recordExistence"+recordExistence);
//           if(recordExistence){
//               
//              int maxSequence= l_studentAssignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_assignmentID)&&rec.getRecord().get(2).trim().equals(p_studentID)&&rec.getRecord().get(3).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
//              
//              sequenceNo=maxSequence+1;
//           }else{
//               sequenceNo=sequenceNo+1;
//           }
//           dbg("sequenceNo"+sequenceNo);
//           
//           
//           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 105, studentAssignmentEodList.get(0).trim(),studentAssignmentEodList.get(1).trim(),studentAssignmentEodList.get(2).trim(),studentAssignmentEodList.get(3).trim(),studentAssignmentEodList.get(4).trim(),studentAssignmentEodList.get(5).trim(),studentAssignmentEodList.get(6).trim(),studentAssignmentEodList.get(7).trim(),Integer.toString(sequenceNo));
//           
//           dbg("end of moveStudentAssignmentRecordToHistory");
//     }catch(DBValidationException ex){
//          throw ex;
////     }catch(BSValidationException ex){
////          throw ex;     
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          throw new DBProcessingException("DBProcessingException"+ex.toString());
////      }catch(BSProcessingException ex){
////           dbg(ex);
////           throw new BSProcessingException(ex.toString());
//     }catch(Exception ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
//     }
//       
//       
//       
//   } 
   public void  moveStudentECircularRecordToHistory(String p_instituteID,String p_eCircularID,String p_studentID,String p_businessDate,DBRecord studentECircularRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentECircularRecordToHistory");
           ArrayList<String>studentECircularEodList=studentECircularRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentOtherActivityHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           List<DBRecord>filteredList=null;
           
           try{
           
           l_studentOtherActivityHistoryMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", "STUDENT_E_CIRCULAR_EOD_STATUS_HISTORY", session, dbSession);
           
           filteredList=l_studentOtherActivityHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_eCircularID)&&rec.getRecord().get(2).trim().equals(p_studentID)&&rec.getRecord().get(3).trim().equals(p_businessDate)).collect(Collectors.toList());
           
           if(filteredList==null||filteredList.isEmpty()){
               
               recordExistence=false;
           }
           
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= filteredList.stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_eCircularID)&&rec.getRecord().get(2).trim().equals(p_studentID)&&rec.getRecord().get(3).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", 296, studentECircularEodList.get(0).trim(),studentECircularEodList.get(1).trim(),studentECircularEodList.get(2).trim(),studentECircularEodList.get(3).trim(),studentECircularEodList.get(4).trim(),studentECircularEodList.get(5).trim(),studentECircularEodList.get(6).trim(),studentECircularEodList.get(7).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentECircularRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   }
   public void  moveTeacherECircularRecordToHistory(String p_instituteID,String p_eCircularID,String p_teacherID,String p_businessDate,DBRecord teacherECircularRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveTeacherECircularRecordToHistory");
           ArrayList<String>teacherECircularEodList=teacherECircularRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_teacherOtherActivityHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           List<DBRecord>filteredList=null;
           
           try{
           
           l_teacherOtherActivityHistoryMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", "TEACHER_E_CIRCULAR_EOD_STATUS_HISTORY", session, dbSession);
           
           filteredList=l_teacherOtherActivityHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_eCircularID)&&rec.getRecord().get(2).trim().equals(p_teacherID)&&rec.getRecord().get(3).trim().equals(p_businessDate)).collect(Collectors.toList());
           
           if(filteredList==null||filteredList.isEmpty()){
               
               recordExistence=false;
           }
           
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= filteredList.stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_eCircularID)&&rec.getRecord().get(2).trim().equals(p_teacherID)&&rec.getRecord().get(3).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", 350, teacherECircularEodList.get(0).trim(),teacherECircularEodList.get(1).trim(),teacherECircularEodList.get(2).trim(),teacherECircularEodList.get(3).trim(),teacherECircularEodList.get(4).trim(),teacherECircularEodList.get(5).trim(),teacherECircularEodList.get(6).trim(),teacherECircularEodList.get(7).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveTeacherECircularRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   }
   
   public void  moveStudentOtherActivityRecordToHistory(String p_instituteID,String p_activityID,String p_studentID,String p_businessDate,DBRecord studentOtherActivityRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentAssignmentRecordToHistory");
           ArrayList<String>studentOtherActivityEodList=studentOtherActivityRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentOtherActivityHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentOtherActivityHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_OTHER_ACTIVITY_EOD_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
               int maxSequence=0;
               
               List<DBRecord>filteredList=l_studentOtherActivityHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_activityID)&&rec.getRecord().get(2).trim().equals(p_studentID)&&rec.getRecord().get(3).trim().equals(p_businessDate)).collect(Collectors.toList());
               
               if(filteredList.isEmpty()){
                   
                   maxSequence= l_studentOtherActivityHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_activityID)&&rec.getRecord().get(2).trim().equals(p_studentID)&&rec.getRecord().get(3).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
                   
               }else{
                   
                   maxSequence=0;
               }

              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 115, studentOtherActivityEodList.get(0).trim(),studentOtherActivityEodList.get(1).trim(),studentOtherActivityEodList.get(2).trim(),studentOtherActivityEodList.get(3).trim(),studentOtherActivityEodList.get(4).trim(),studentOtherActivityEodList.get(5).trim(),studentOtherActivityEodList.get(6).trim(),studentOtherActivityEodList.get(7).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentAssignmentRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
//    public void  moveStudentAssignmentRecordToHistory(String p_instituteID,String p_activityID,String p_studentID,String p_businessDate,DBRecord studentAssignmentRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
//       
//       try{
//           dbg("inside moveStudentAssignmentRecordToHistory");
//           ArrayList<String>studentAssignmentEodList=studentAssignmentRecord.getRecord();
//           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//           IDBTransactionService dbts=inject.getDBTransactionService();
//           Map<String,DBRecord>l_studentAssignmentHistoryMap=null;
//           boolean recordExistence=true;
//           int sequenceNo=0;
//           
//           try{
//           
//           l_studentAssignmentHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS_HISTORY", session, dbSession);
//           
//          }catch(DBValidationException ex){
//            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
//                 
//			  recordExistence=false;
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
//              
//                        }else{
//
//                              throw ex;
//                        }
//         }
//           dbg("recordExistence"+recordExistence);
//           if(recordExistence){
//               
//               int maxSequence=0;
//               
//               List<DBRecord>filteredList=l_studentAssignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_activityID)&&rec.getRecord().get(2).trim().equals(p_studentID)&&rec.getRecord().get(3).trim().equals(p_businessDate)).collect(Collectors.toList());
//               
//               if(filteredList.isEmpty()){
//                   
//                   maxSequence= l_studentAssignmentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_activityID)&&rec.getRecord().get(2).trim().equals(p_studentID)&&rec.getRecord().get(3).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
//                   
//               }else{
//                   
//                   maxSequence=0;
//               }
//
//              sequenceNo=maxSequence+1;
//           }else{
//               sequenceNo=sequenceNo+1;
//           }
//           dbg("sequenceNo"+sequenceNo);
//           
//           
//           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 105, studentAssignmentEodList.get(0).trim(),studentAssignmentEodList.get(1).trim(),studentAssignmentEodList.get(2).trim(),studentAssignmentEodList.get(3).trim(),studentAssignmentEodList.get(4).trim(),studentAssignmentEodList.get(5).trim(),studentAssignmentEodList.get(6).trim(),studentAssignmentEodList.get(7).trim(),Integer.toString(sequenceNo));
//           
//           dbg("end of moveStudentAssignmentRecordToHistory");
//     }catch(DBValidationException ex){
//          throw ex;
////     }catch(BSValidationException ex){
////          throw ex;     
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          throw new DBProcessingException("DBProcessingException"+ex.toString());
////      }catch(BSProcessingException ex){
////           dbg(ex);
////           throw new BSProcessingException(ex.toString());
//     }catch(Exception ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
//     }
//       
//       
//       
//   } 
    public void  moveStudentAssignmentRecordToHistory(String p_instituteID,String p_assignmentID,String p_studentID,String p_businessDate,DBRecord studentAssignmentRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentAssignmentRecordToHistory");
           ArrayList<String>studentAssignmentEodList=studentAssignmentRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentOtherActivityHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           List<DBRecord>filteredList=null;
           
           try{
           
           l_studentOtherActivityHistoryMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Assignment"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_assignmentID, "BATCH", "STUDENT_ASSIGNMENT_EOD_STATUS_HISTORY", session, dbSession);
           
           filteredList=l_studentOtherActivityHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_assignmentID)&&rec.getRecord().get(2).trim().equals(p_studentID)&&rec.getRecord().get(3).trim().equals(p_businessDate)).collect(Collectors.toList());
           
           if(filteredList==null||filteredList.isEmpty()){
               
               recordExistence=false;
           }
           
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= filteredList.stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_assignmentID)&&rec.getRecord().get(2).trim().equals(p_studentID)&&rec.getRecord().get(3).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Assignment"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_assignmentID, "BATCH", 105, studentAssignmentEodList.get(0).trim(),studentAssignmentEodList.get(1).trim(),studentAssignmentEodList.get(2).trim(),studentAssignmentEodList.get(3).trim(),studentAssignmentEodList.get(4).trim(),studentAssignmentEodList.get(5).trim(),studentAssignmentEodList.get(6).trim(),studentAssignmentEodList.get(7).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentAssignmentRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   }
    
    
//    public void  moveStudentEventNotificationRecordToHistory(String p_instituteID,String p_studentID,String p_businessDate,DBRecord studentEventNotificationRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
//       
//       try{
//           dbg("inside moveStudentEventNotificationRecordToHistory");
//           ArrayList<String>studentEventNotificationEodList=studentEventNotificationRecord.getRecord();
//           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//           IDBTransactionService dbts=inject.getDBTransactionService();
//           Map<String,DBRecord>l_studentEventNotificationHistoryMap=null;
//           boolean recordExistence=true;
//           int sequenceNo=0;
//           
//           try{
//           
//           l_studentEventNotificationHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_EVENT_NOTIFICATION_EOD_STATUS_HISTORY", session, dbSession);
//           
//           
//           
//           
//           
//           
//          }catch(DBValidationException ex){
//            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
//                 
//			  recordExistence=false;
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
//              
//                        }else{
//
//                              throw ex;
//                        }
//         }
//           dbg("recordExistence"+recordExistence);
//           if(recordExistence){
//               
//               int maxSequence=0;
//               
//               List<DBRecord>filteredList=l_studentEventNotificationHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_studentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).collect(Collectors.toList());
//               
//               if(filteredList.isEmpty()){
//                   
//                   maxSequence= l_studentEventNotificationHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_studentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
//                   
//               }else{
//                   
//                   maxSequence=0;
//               }
//
//              sequenceNo=maxSequence+1;
//           }else{
//               sequenceNo=sequenceNo+1;
//           }
//           dbg("sequenceNo"+sequenceNo);
//           
//           
//           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 340, studentEventNotificationEodList.get(0).trim(),studentEventNotificationEodList.get(1).trim(),studentEventNotificationEodList.get(2).trim(),studentEventNotificationEodList.get(3).trim(),studentEventNotificationEodList.get(4).trim(),studentEventNotificationEodList.get(5).trim(),Integer.toString(sequenceNo));
//           
//           dbg("end of moveStudentEventNotificationRecordToHistory");
//     }catch(DBValidationException ex){
//          throw ex;
////     }catch(BSValidationException ex){
////          throw ex;     
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          throw new DBProcessingException("DBProcessingException"+ex.toString());
////      }catch(BSProcessingException ex){
////           dbg(ex);
////           throw new BSProcessingException(ex.toString());
//     }catch(Exception ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
//     }
//       
//       
//       
//   }
    
    public void  moveStudentEventNotificationRecordToHistory(String p_instituteID,String p_studentID,String p_businessDate,DBRecord studentEventNotification,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentEventNotificationToHistory");
           ArrayList<String>studentEventEodList=studentEventNotification.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentEventNotificationHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           List<DBRecord>filteredList=null;
           
           try{
           
           l_studentEventNotificationHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_EVENT_NOTIFICATION_EOD_STATUS_HISTORY", session, dbSession);
           
           filteredList=l_studentEventNotificationHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_studentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).collect(Collectors.toList());
           
           if(filteredList==null||filteredList.isEmpty()){
               
               recordExistence=false;
           }
           
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= filteredList.stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_studentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 340, studentEventNotification.getRecord().get(0).trim(),studentEventNotification.getRecord().get(1).trim(),studentEventNotification.getRecord().get(2).trim(),studentEventNotification.getRecord().get(3).trim(),studentEventNotification.getRecord().get(4).trim(),studentEventNotification.getRecord().get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentEventNotificationToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
   public void  moveStudentFeeRecordToHistory(String p_instituteID,String p_feeID,String p_studentID,String p_businessDate,DBRecord studentFeeRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentFeeRecordToHistory");
           ArrayList<String>studentFeeEodList=studentFeeRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentOtherActivityHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           List<DBRecord>filteredList=null;
           
           try{
           
           l_studentOtherActivityHistoryMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Fee"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_EOD_STATUS_HISTORY", session, dbSession);
           
           filteredList=l_studentOtherActivityHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(2).trim().equals(p_studentID)&&rec.getRecord().get(3).trim().equals(p_businessDate)).collect(Collectors.toList());
           
           if(filteredList==null||filteredList.isEmpty()){
               
               recordExistence=false;
           }
           
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= filteredList.stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(2).trim().equals(p_studentID)&&rec.getRecord().get(3).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Fee"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", 121, studentFeeEodList.get(0).trim(),studentFeeEodList.get(1).trim(),studentFeeEodList.get(2).trim(),studentFeeEodList.get(3).trim(),studentFeeEodList.get(4).trim(),studentFeeEodList.get(5).trim(),studentFeeEodList.get(6).trim(),studentFeeEodList.get(7).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentFeeRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   }
   public void  moveStudentFeeNotificationToHistory(String p_instituteID,String p_feeID,String p_studentID,String p_businessDate,DBRecord studentFeeNotification,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentFeeNotificationToHistory");
           ArrayList<String>studentFeeEodList=studentFeeNotification.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentOtherActivityHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           List<DBRecord>filteredList=null;
           
           try{
           
           l_studentOtherActivityHistoryMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"FeeNotification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_NOTIFICATION_EOD_STATUS_HISTORY", session, dbSession);
           
           filteredList=l_studentOtherActivityHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(2).trim().equals(p_studentID)&&rec.getRecord().get(3).trim().equals(p_businessDate)).collect(Collectors.toList());
           
           if(filteredList==null||filteredList.isEmpty()){
               
               recordExistence=false;
           }
           
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= filteredList.stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(2).trim().equals(p_studentID)&&rec.getRecord().get(3).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"FeeNotification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", 337, studentFeeEodList.get(0).trim(),studentFeeEodList.get(1).trim(),studentFeeEodList.get(2).trim(),studentFeeEodList.get(3).trim(),studentFeeEodList.get(4).trim(),studentFeeEodList.get(5).trim(),studentFeeEodList.get(6).trim(),studentFeeEodList.get(7).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentFeeNotificationToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
   
    
   
   
   
   public void  moveStudentNotificationRecordToHistory(String p_instituteID,String p_notificationID,String p_studentID,String p_businessDate,DBRecord studentNotificationRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentFeeRecordToHistory");
           ArrayList<String>studentNotificationEodList=studentNotificationRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentOtherActivityHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           List<DBRecord>filteredList=null;
           try{
           
           l_studentOtherActivityHistoryMap=readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_notificationID, "BATCH", "STUDENT_NOTIFICATION_EOD_STATUS_HISTORY", session, dbSession);
           
           filteredList=l_studentOtherActivityHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_notificationID)&&rec.getRecord().get(2).trim().equals(p_studentID)&&rec.getRecord().get(3).trim().equals(p_businessDate)).collect(Collectors.toList());
           
           if(filteredList==null||filteredList.isEmpty()){
               
               recordExistence=false;
           }
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= filteredList.stream().mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_notificationID, "BATCH", 128, studentNotificationEodList.get(0).trim(),studentNotificationEodList.get(1).trim(),studentNotificationEodList.get(2).trim(),studentNotificationEodList.get(3).trim(),studentNotificationEodList.get(4).trim(),studentNotificationEodList.get(5).trim(),studentNotificationEodList.get(6).trim(),studentNotificationEodList.get(7).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentFeeRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
   
   public void  moveStudentTimeTableRecordToHistory(String p_instituteID,String p_standard,String p_section,String p_studentID,String p_businessDate,DBRecord studentTimeTableRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentTimeTableRecordToHistory");
           ArrayList<String>studentTimeTableEodList=studentTimeTableRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentOtherActivityHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentOtherActivityHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_TIMETABLE_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentOtherActivityHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(3).trim().equals(p_studentID)&&rec.getRecord().get(4).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 134, studentTimeTableEodList.get(0).trim(),studentTimeTableEodList.get(1).trim(),studentTimeTableEodList.get(2).trim(),studentTimeTableEodList.get(3).trim(),studentTimeTableEodList.get(4).trim(),studentTimeTableEodList.get(5).trim(),studentTimeTableEodList.get(6).trim(),studentTimeTableEodList.get(7).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentTimeTableRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    public void  moveStudentExamRecordToHistory(String p_instituteID,String p_standard,String p_section,String p_exam,String p_studentID,String p_businessDate,DBRecord studentExamRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentExamRecordToHistory");
           ArrayList<String>studentExamEodList=studentExamRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentOtherActivityHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentOtherActivityHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_EXAM_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentOtherActivityHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(3).trim().equals(p_exam)&&rec.getRecord().get(4).trim().equals(p_studentID)&&rec.getRecord().get(5).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(9).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 140, studentExamEodList.get(0).trim(),studentExamEodList.get(1).trim(),studentExamEodList.get(2).trim(),studentExamEodList.get(3).trim(),studentExamEodList.get(4).trim(),studentExamEodList.get(5).trim(),studentExamEodList.get(6).trim(),studentExamEodList.get(7).trim(),studentExamEodList.get(8).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentExamRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    public void  moveStudentMarkRecordToHistory(String p_instituteID,String p_standard,String p_section,String p_exam,String p_subjectID,String p_studentID,String p_businessDate,DBRecord studentMarkRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentMarkRecordToHistory");
           ArrayList<String>studentMarkEodList=studentMarkRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentOtherActivityHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentOtherActivityHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_MARK_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentOtherActivityHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(3).trim().equals(p_exam)&&rec.getRecord().get(4).trim().equals(p_subjectID)&&rec.getRecord().get(5).trim().equals(p_studentID)&&rec.getRecord().get(6).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(10).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 146, studentMarkEodList.get(0).trim(),studentMarkEodList.get(1).trim(),studentMarkEodList.get(2).trim(),studentMarkEodList.get(3).trim(),studentMarkEodList.get(4).trim(),studentMarkEodList.get(5).trim(),studentMarkEodList.get(6).trim(),studentMarkEodList.get(7).trim(),studentMarkEodList.get(8).trim(),studentMarkEodList.get(9).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentMarkRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    public void  moveStudentAttendanceRecordToHistory(String p_instituteID,String p_standard,String p_section,String p_studentID,String p_businessDate,DBRecord studentAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentAttendanceRecordToHistory");
           ArrayList<String>studentAttendanceEodList=studentAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentOtherActivityHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentOtherActivityHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_ATTENDANCE_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentOtherActivityHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(3).trim().equals(p_studentID)&&rec.getRecord().get(4).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(8).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 152, studentAttendanceEodList.get(0).trim(),studentAttendanceEodList.get(1).trim(),studentAttendanceEodList.get(2).trim(),studentAttendanceEodList.get(3).trim(),studentAttendanceEodList.get(4).trim(),studentAttendanceEodList.get(5).trim(),studentAttendanceEodList.get(6).trim(),studentAttendanceEodList.get(7).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentAttendanceRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    
    public void  moveStudentAssignmentArchRecordToHistory(String p_instituteID,String p_studentID,String p_businessDate,DBRecord studentAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentAssignmentArchRecordToHistory");
           ArrayList<String>studentAttendanceEodList=studentAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentOtherActivityHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentOtherActivityHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_ASSIGNMENT_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentOtherActivityHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_studentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 155, studentAttendanceEodList.get(0).trim(),studentAttendanceEodList.get(1).trim(),studentAttendanceEodList.get(2).trim(),studentAttendanceEodList.get(3).trim(),studentAttendanceEodList.get(4).trim(),studentAttendanceEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentAssignmentArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    
    public void  moveInstituteAssignmentArchRecordToHistory(String p_instituteID,String p_businessDate,DBRecord studentAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveInstituteAssignmentArchRecordToHistory");
           ArrayList<String>studentAttendanceEodList=studentAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentOtherActivityHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentOtherActivityHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "INSTITUTE_ASSIGNMENT_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentOtherActivityHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(5).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 158, studentAttendanceEodList.get(0).trim(),studentAttendanceEodList.get(1).trim(),studentAttendanceEodList.get(2).trim(),studentAttendanceEodList.get(3).trim(),studentAttendanceEodList.get(4).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveInstituteAssignmentArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    
    public void  moveStudentOtherActivityArchRecordToHistory(String p_instituteID,String p_studentID,String p_businessDate,DBRecord studentAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentOtherActivityArchRecordToHistory");
           ArrayList<String>studentAttendanceEodList=studentAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentOtherActivityHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentOtherActivityHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_OTHER_ACTIVITY_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentOtherActivityHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_studentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 161, studentAttendanceEodList.get(0).trim(),studentAttendanceEodList.get(1).trim(),studentAttendanceEodList.get(2).trim(),studentAttendanceEodList.get(3).trim(),studentAttendanceEodList.get(4).trim(),studentAttendanceEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentOtherActivityArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    
    public void  moveInstituteOtherActivityArchRecordToHistory(String p_instituteID,String p_businessDate,DBRecord studentAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveInstituteOtherActivityArchRecordToHistory");
           ArrayList<String>studentAttendanceEodList=studentAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentOtherActivityHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentOtherActivityHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "INSTITUTE_OTHER_ACTIVITY_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentOtherActivityHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(5).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 164, studentAttendanceEodList.get(0).trim(),studentAttendanceEodList.get(1).trim(),studentAttendanceEodList.get(2).trim(),studentAttendanceEodList.get(3).trim(),studentAttendanceEodList.get(4).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveInstituteOtherActivityArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    
    public void  moveStudentFeeArchRecordToHistory(String p_instituteID,String p_studentID,String p_businessDate,DBRecord studentAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentFeeArchRecordToHistory");
           ArrayList<String>studentAttendanceEodList=studentAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentFeeHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentFeeHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_FEE_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentFeeHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_studentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 167, studentAttendanceEodList.get(0).trim(),studentAttendanceEodList.get(1).trim(),studentAttendanceEodList.get(2).trim(),studentAttendanceEodList.get(3).trim(),studentAttendanceEodList.get(4).trim(),studentAttendanceEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentFeeArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    
    public void  moveInstituteFeeArchRecordToHistory(String p_instituteID,String p_businessDate,DBRecord studentAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveInstituteFeeArchRecordToHistory");
           ArrayList<String>studentAttendanceEodList=studentAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentFeeHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentFeeHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "INSTITUTE_FEE_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentFeeHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(5).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 170, studentAttendanceEodList.get(0).trim(),studentAttendanceEodList.get(1).trim(),studentAttendanceEodList.get(2).trim(),studentAttendanceEodList.get(3).trim(),studentAttendanceEodList.get(4).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveInstituteFeeArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    
    
     public void  moveStudentNotificationArchRecordToHistory(String p_instituteID,String p_studentID,String p_businessDate,DBRecord studentAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentNotificationArchRecordToHistory");
           ArrayList<String>studentAttendanceEodList=studentAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentNotificationHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentNotificationHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_NOTIFICATION_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentNotificationHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_studentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 173, studentAttendanceEodList.get(0).trim(),studentAttendanceEodList.get(1).trim(),studentAttendanceEodList.get(2).trim(),studentAttendanceEodList.get(3).trim(),studentAttendanceEodList.get(4).trim(),studentAttendanceEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentNotificationArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    
    public void  moveInstituteNotificationArchRecordToHistory(String p_instituteID,String p_businessDate,DBRecord studentAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveInstituteNotificationArchRecordToHistory");
           ArrayList<String>studentAttendanceEodList=studentAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentNotificationHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentNotificationHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "INSTITUTE_NOTIFICATION_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentNotificationHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(5).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 176, studentAttendanceEodList.get(0).trim(),studentAttendanceEodList.get(1).trim(),studentAttendanceEodList.get(2).trim(),studentAttendanceEodList.get(3).trim(),studentAttendanceEodList.get(4).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveInstituteNotificationArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    public void  moveStudentMarkArchRecordToHistory(String p_instituteID,String p_studentID,String p_businessDate,DBRecord studentAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentMarkArchRecordToHistory");
           ArrayList<String>studentAttendanceEodList=studentAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentMarkHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentMarkHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_MARK_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentMarkHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_studentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 179, studentAttendanceEodList.get(0).trim(),studentAttendanceEodList.get(1).trim(),studentAttendanceEodList.get(2).trim(),studentAttendanceEodList.get(3).trim(),studentAttendanceEodList.get(4).trim(),studentAttendanceEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentMarkArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    public void  moveClassMarkArchRecordToHistory(String p_instituteID,String p_standard,String p_section,String p_businessDate,DBRecord classAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveClassMarkArchRecordToHistory");
           ArrayList<String>classAttendanceEodList=classAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_classMarkHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_classMarkHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "CLASS_MARK_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_classMarkHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(3).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(7).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 182, classAttendanceEodList.get(0).trim(),classAttendanceEodList.get(1).trim(),classAttendanceEodList.get(2).trim(),classAttendanceEodList.get(3).trim(),classAttendanceEodList.get(4).trim(),classAttendanceEodList.get(5).trim(),classAttendanceEodList.get(6).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveClassMarkArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    
    public void  moveStudentExamArchRecordToHistory(String p_instituteID,String p_studentID,String p_businessDate,DBRecord studentAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentExamArchRecordToHistory");
           ArrayList<String>studentAttendanceEodList=studentAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentExamHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentExamHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_EXAM_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentExamHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_studentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 185, studentAttendanceEodList.get(0).trim(),studentAttendanceEodList.get(1).trim(),studentAttendanceEodList.get(2).trim(),studentAttendanceEodList.get(3).trim(),studentAttendanceEodList.get(4).trim(),studentAttendanceEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentExamArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    public void  moveClassExamArchRecordToHistory(String p_instituteID,String p_standard,String p_section,String p_businessDate,DBRecord classAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveClassExamArchRecordToHistory");
           ArrayList<String>classAttendanceEodList=classAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_classExamHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_classExamHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "CLASS_EXAM_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
           if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_classExamHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(3).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(7).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 188, classAttendanceEodList.get(0).trim(),classAttendanceEodList.get(1).trim(),classAttendanceEodList.get(2).trim(),classAttendanceEodList.get(3).trim(),classAttendanceEodList.get(4).trim(),classAttendanceEodList.get(5).trim(),classAttendanceEodList.get(6).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveClassExamArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    public void  moveStudentTimeTableArchRecordToHistory(String p_instituteID,String p_studentID,String p_businessDate,DBRecord studentAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentTimeTableArchRecordToHistory");
           ArrayList<String>studentAttendanceEodList=studentAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentTimeTableHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentTimeTableHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_TIME_TABLE_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentTimeTableHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_studentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 191, studentAttendanceEodList.get(0).trim(),studentAttendanceEodList.get(1).trim(),studentAttendanceEodList.get(2).trim(),studentAttendanceEodList.get(3).trim(),studentAttendanceEodList.get(4).trim(),studentAttendanceEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentTimeTableArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    public void  moveClassTimeTableArchRecordToHistory(String p_instituteID,String p_standard,String p_section,String p_businessDate,DBRecord classAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveClassTimeTableArchRecordToHistory");
           ArrayList<String>classAttendanceEodList=classAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_classTimeTableHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_classTimeTableHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "CLASS_TIME_TABLE_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
           if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_classTimeTableHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(3).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(7).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 194, classAttendanceEodList.get(0).trim(),classAttendanceEodList.get(1).trim(),classAttendanceEodList.get(2).trim(),classAttendanceEodList.get(3).trim(),classAttendanceEodList.get(4).trim(),classAttendanceEodList.get(5).trim(),classAttendanceEodList.get(6).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveClassTimeTableArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    
  public void  moveStudentAttendanceArchRecordToHistory(String p_instituteID,String p_studentID,String p_businessDate,DBRecord studentAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentAttendanceArchRecordToHistory");
           ArrayList<String>studentAttendanceEodList=studentAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentAttendanceHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentAttendanceHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_ATTENDANCE_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentAttendanceHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_studentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 197, studentAttendanceEodList.get(0).trim(),studentAttendanceEodList.get(1).trim(),studentAttendanceEodList.get(2).trim(),studentAttendanceEodList.get(3).trim(),studentAttendanceEodList.get(4).trim(),studentAttendanceEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentAttendanceArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    public void  moveClassAttendanceArchRecordToHistory(String p_instituteID,String p_standard,String p_section,String p_businessDate,DBRecord classAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveClassAttendanceArchRecordToHistory");
           ArrayList<String>classAttendanceEodList=classAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_classAttendanceHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_classAttendanceHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "CLASS_ATTENDANCE_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
           if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_classAttendanceHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(3).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(7).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 200, classAttendanceEodList.get(0).trim(),classAttendanceEodList.get(1).trim(),classAttendanceEodList.get(2).trim(),classAttendanceEodList.get(3).trim(),classAttendanceEodList.get(4).trim(),classAttendanceEodList.get(5).trim(),classAttendanceEodList.get(6).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveClassAttendanceArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   }   
    
   public void  moveStudentLeaveArchRecordToHistory(String p_instituteID,String p_studentID,String p_businessDate,DBRecord studentLeaveRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentLeaveArchRecordToHistory");
           ArrayList<String>studentLeaveEodList=studentLeaveRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentLeaveHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentLeaveHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_LEAVE_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentLeaveHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_studentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 203, studentLeaveEodList.get(0).trim(),studentLeaveEodList.get(1).trim(),studentLeaveEodList.get(2).trim(),studentLeaveEodList.get(3).trim(),studentLeaveEodList.get(4).trim(),studentLeaveEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentLeaveArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
   
   public void  moveTeacherLeaveArchRecordToHistory(String p_instituteID,String p_teacherID,String p_businessDate,DBRecord teacherLeaveRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveTeacherLeaveArchRecordToHistory");
           ArrayList<String>teacherLeaveEodList=teacherLeaveRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_teacherLeaveHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_teacherLeaveHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "TEACHER_LEAVE_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_teacherLeaveHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_teacherID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 206, teacherLeaveEodList.get(0).trim(),teacherLeaveEodList.get(1).trim(),teacherLeaveEodList.get(2).trim(),teacherLeaveEodList.get(3).trim(),teacherLeaveEodList.get(4).trim(),teacherLeaveEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveTeacherLeaveArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
   
   public void  moveStudentCalenderArchRecordToHistory(String p_instituteID,String p_studentID,String p_businessDate,DBRecord studentCalenderRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentCalenderArchRecordToHistory");
           ArrayList<String>studentCalenderEodList=studentCalenderRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentCalenderHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentCalenderHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_CALENDER_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentCalenderHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_studentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 210, studentCalenderEodList.get(0).trim(),studentCalenderEodList.get(1).trim(),studentCalenderEodList.get(2).trim(),studentCalenderEodList.get(3).trim(),studentCalenderEodList.get(4).trim(),studentCalenderEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentCalenderArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
   
   public void  moveTeacherCalenderArchRecordToHistory(String p_instituteID,String p_teacherID,String p_businessDate,DBRecord teacherCalenderRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveTeacherCalenderArchRecordToHistory");
           ArrayList<String>teacherCalenderEodList=teacherCalenderRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_teacherCalenderHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_teacherCalenderHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "TEACHER_CALENDER_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_teacherCalenderHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_teacherID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 213, teacherCalenderEodList.get(0).trim(),teacherCalenderEodList.get(1).trim(),teacherCalenderEodList.get(2).trim(),teacherCalenderEodList.get(3).trim(),teacherCalenderEodList.get(4).trim(),teacherCalenderEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveTeacherCalenderArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
  public void  moveTeacherPayrollArchRecordToHistory(String p_instituteID,String p_teacherID,String p_businessDate,DBRecord teacherPayrollRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveTeacherPayrollArchRecordToHistory");
           ArrayList<String>teacherPayrollEodList=teacherPayrollRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_teacherPayrollHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_teacherPayrollHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "TEACHER_PAYROLL_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_teacherPayrollHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_teacherID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 216, teacherPayrollEodList.get(0).trim(),teacherPayrollEodList.get(1).trim(),teacherPayrollEodList.get(2).trim(),teacherPayrollEodList.get(3).trim(),teacherPayrollEodList.get(4).trim(),teacherPayrollEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveTeacherPayrollArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   }  
  
  
  public void  moveStudentPaymentArchRecordToHistory(String p_instituteID,String p_studentID,String p_businessDate,DBRecord studentAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentPaymentArchRecordToHistory");
           ArrayList<String>studentAttendanceEodList=studentAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentPaymentHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentPaymentHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_PAYMENT_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentPaymentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_studentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 219, studentAttendanceEodList.get(0).trim(),studentAttendanceEodList.get(1).trim(),studentAttendanceEodList.get(2).trim(),studentAttendanceEodList.get(3).trim(),studentAttendanceEodList.get(4).trim(),studentAttendanceEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentPaymentArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    
    public void  moveInstitutePaymentArchRecordToHistory(String p_instituteID,String p_businessDate,DBRecord studentAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveInstitutePaymentArchRecordToHistory");
           ArrayList<String>studentAttendanceEodList=studentAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentPaymentHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentPaymentHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "INSTITUTE_PAYMENT_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentPaymentHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(5).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 222, studentAttendanceEodList.get(0).trim(),studentAttendanceEodList.get(1).trim(),studentAttendanceEodList.get(2).trim(),studentAttendanceEodList.get(3).trim(),studentAttendanceEodList.get(4).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveInstitutePaymentArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    
    public void  moveTeacherAttendanceArchRecordToHistory(String p_instituteID,String p_teacherID,String p_businessDate,DBRecord teacherAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveTeacherAttendanceArchRecordToHistory");
           ArrayList<String>teacherAttendanceEodList=teacherAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_teacherAttendanceHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_teacherAttendanceHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "TEACHER_ATTENDANCE_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_teacherAttendanceHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_teacherID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 225, teacherAttendanceEodList.get(0).trim(),teacherAttendanceEodList.get(1).trim(),teacherAttendanceEodList.get(2).trim(),teacherAttendanceEodList.get(3).trim(),teacherAttendanceEodList.get(4).trim(),teacherAttendanceEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveTeacherAttendanceArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    public void  moveTeacherTimeTableArchRecordToHistory(String p_instituteID,String p_teacherID,String p_businessDate,DBRecord teacherAttendanceRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveTeacherTimeTableArchRecordToHistory");
           ArrayList<String>teacherAttendanceEodList=teacherAttendanceRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_teacherTimeTableHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_teacherTimeTableHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "TEACHER_TIME_TABLE_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_teacherTimeTableHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_teacherID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 228, teacherAttendanceEodList.get(0).trim(),teacherAttendanceEodList.get(1).trim(),teacherAttendanceEodList.get(2).trim(),teacherAttendanceEodList.get(3).trim(),teacherAttendanceEodList.get(4).trim(),teacherAttendanceEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveTeacherTimeTableArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    public void  moveStudentProfileArchRecordToHistory(String p_instituteID,String p_studentID,String p_businessDate,DBRecord studentProfileRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveStudentProfileArchRecordToHistory");
           ArrayList<String>studentProfileEodList=studentProfileRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_studentProfileHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_studentProfileHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "STUDENT_PROFILE_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_studentProfileHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_studentID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 231, studentProfileEodList.get(0).trim(),studentProfileEodList.get(1).trim(),studentProfileEodList.get(2).trim(),studentProfileEodList.get(3).trim(),studentProfileEodList.get(4).trim(),studentProfileEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveStudentProfileArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
   
   public void  moveTeacherProfileArchRecordToHistory(String p_instituteID,String p_teacherID,String p_businessDate,DBRecord teacherProfileRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveTeacherProfileArchRecordToHistory");
           ArrayList<String>teacherProfileEodList=teacherProfileRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_teacherProfileHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_teacherProfileHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "TEACHER_PROFILE_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_teacherProfileHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_teacherID)&&rec.getRecord().get(2).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(6).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 234, teacherProfileEodList.get(0).trim(),teacherProfileEodList.get(1).trim(),teacherProfileEodList.get(2).trim(),teacherProfileEodList.get(3).trim(),teacherProfileEodList.get(4).trim(),teacherProfileEodList.get(5).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveTeacherProfileArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
   
   public void  moveUserProfileArchRecordToHistory(String p_userID,String p_businessDate,DBRecord userProfileRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveUserProfileArchRecordToHistory");
           ArrayList<String>userProfileEodList=userProfileRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           Map<String,DBRecord>l_userProfileHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_userProfileHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "USER_PROFILE_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_userProfileHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_userID)&&rec.getRecord().get(1).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(5).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", 237, userProfileEodList.get(0).trim(),userProfileEodList.get(1).trim(),userProfileEodList.get(2).trim(),userProfileEodList.get(3).trim(),userProfileEodList.get(4).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveUserProfileArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
   
   public void  moveDefragmentationArchRecordToHistory(String p_fileName,String p_businessDate,DBRecord userProfileRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveDefragmentationArchRecordToHistory");
           ArrayList<String>userProfileEodList=userProfileRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           IMetaDataService mds=inject.getMetadataservice();
           Map<String,DBRecord>l_userProfileHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_userProfileHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "DEFRAGMENTATION_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_userProfileHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_fileName)&&rec.getRecord().get(1).trim().equals(p_businessDate)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(5).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           int tableId=mds.getTableMetaData("BATCH", "DEFRAGMENTATION_ARCH_BATCH_STATUS_HISTORY",session).getI_Tableid();
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", tableId, userProfileEodList.get(0).trim(),userProfileEodList.get(1).trim(),userProfileEodList.get(2).trim(),userProfileEodList.get(3).trim(),userProfileEodList.get(4).trim(),Integer.toString(sequenceNo),userProfileEodList.get(6).trim());
           
           dbg("end of moveDefragmentationArchRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
   public void  moveArchivalRecoveryRecordToHistory(String p_fileName,String p_businessDate,DBRecord userProfileRecord,CohesiveSession session,DBSession dbSession,AppDependencyInjection inject)throws DBProcessingException,DBValidationException,BSValidationException,BSProcessingException{
       
       try{
           dbg("inside moveArchivalRecoveryRecordToHistory");
           ArrayList<String>userProfileEodList=userProfileRecord.getRecord();
           IDBReadBufferService readBuffer=inject.getDBReadBufferService();
           IDBTransactionService dbts=inject.getDBTransactionService();
           IMetaDataService mds=inject.getMetadataservice();
           Map<String,DBRecord>l_userProfileHistoryMap=null;
           boolean recordExistence=true;
           int sequenceNo=0;
           
           try{
           
           l_userProfileHistoryMap=readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", "ARCHIVAL_RECOVERY_ARCH_BATCH_STATUS_HISTORY", session, dbSession);
           
          }catch(DBValidationException ex){
            if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
         }
           dbg("recordExistence"+recordExistence);
           if(recordExistence){
               
              int maxSequence= l_userProfileHistoryMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_fileName)).mapToInt(rec->Integer.parseInt(rec.getRecord().get(4).trim())).max().getAsInt();
              
              sequenceNo=maxSequence+1;
           }else{
               sequenceNo=sequenceNo+1;
           }
           dbg("sequenceNo"+sequenceNo);
           int tableId=mds.getTableMetaData("BATCH", "ARCHIVAL_RECOVERY_ARCH_BATCH_STATUS_HISTORY",session).getI_Tableid();
           
           dbts.createRecord(session, "BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+p_businessDate, "BATCH", tableId, userProfileEodList.get(0).trim(),userProfileEodList.get(1).trim(),userProfileEodList.get(2).trim(),userProfileEodList.get(3).trim(),Integer.toString(sequenceNo));
           
           dbg("end of moveArchivalRecoveryRecordToHistory");
     }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
       
       
       
   } 
    public String getReplacedException(String exception)throws BSProcessingException{
        
        try{
            dbg("getReplacedException"+exception);
//            String replacedException=null;
            if(exception.contains("~")){
                
              exception=  exception.replace("~", " ");
            }
            if(exception.contains("#")){
                
              exception=  exception.replace("#", " ");
            }
            if(exception.contains("@")){
                
              exception=  exception.replace("@", " ");
            }
           
            if(exception.length()>200){
                
                exception=exception.substring(0,199);
            }
            
            dbg("end of getReplacedException"+exception);
            return exception;
        }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
        }
        
        
    }
    
//     public void otherActivityProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_activityID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        ITransactionControlService tc=null;
//        try{
//            dbg("inside otherActivityProcessingErrorHandler");
//            dbg("exception"+e);
//            tc=inject.getTransactionControlService();
//            Map<String,String>column_to_Update=new HashMap();
//            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//            IDBTransactionService dbts=inject.getDBTransactionService();
//            BusinessService bs=inject.getBusinessService(session);
//            String endTime=bs.getCurrentDateTime();
//            Map<String,DBRecord>l_studentMap=null;
//            
//            
//            try{
//             tc.rollBack(session, dbSession);
//             }catch(DBProcessingException ex1){
//                 dbg(ex1);
//             }
//            
//             boolean exceptionRaised=false; 
//                try{
//            
//                     l_studentMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_OTHER_ACTIVITY_EOD_STATUS", session, dbSession);
//                     
//                }catch(Exception exe){
//                     exceptionRaised=true;
//                     column_to_Update=new HashMap();
//                     column_to_Update.put("4", "F");
//                     column_to_Update.put("10", endTime);
//                     String[] l_pkey={p_instituteID,p_activityID,l_businessDate};
//                     dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "OTHER_ACTIVITY_EOD_STATUS", l_pkey, column_to_Update,session); 
//                     updateOtherActivityErrorTable(l_businessDate,p_instituteID,p_activityID,exe,l_pkey,inject,session,dbSession);
//                }  
//               
//                if(!exceptionRaised){
//                   
//                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_activityID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
//                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_activityID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
//                   dbg("successRecords"+successRecords);
//                   dbg("failedRecords"+failedRecords);
//                   dbg("end time"+endTime);
//
//                   
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("4", "F");
//                   column_to_Update.put("6", Integer.toString(successRecords));
//                   column_to_Update.put("7", Integer.toString(failedRecords));
//                   column_to_Update.put("10", endTime);
//                   String[] l_pkey={p_instituteID,p_activityID,l_businessDate};
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "OTHER_ACTIVITY_EOD_STATUS", l_pkey, column_to_Update,session); 
//                   updateOtherActivityErrorTable(l_businessDate,p_instituteID,p_activityID,e,l_pkey,inject,session,dbSession);
//                   
//                }  
//                   
//                   
//                   
//                   
//            
//            dbg("end of otherActivityProcessingErrorHandler");
//    tc.commit(session, dbSession);
//    }catch(DBValidationException ex){
//         try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(Exception ex){
//           dbg(ex);
//           try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }
//        
//        
//    }
//    
//    
//     private void updateOtherActivityErrorTable(String l_businessDate,String p_instituteID,String p_activityID,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        
//        try{
//            dbg("inside update otherActivity error table");
//            Map<String,String>column_to_Update;
//            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
//            e.printStackTrace(new PrintWriter(sw));
//            String exceptionAsString = sw.toString();
//            String l_replacedException=getReplacedException(exceptionAsString);
//            
//              boolean recordExistence=true;
//                   
//                   try{
//                       
//                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS_ERROR", l_pkey, session, dbSession,true);
//                       
//                   }catch(DBValidationException ex){
//                       
//                      if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
//                 
//			  recordExistence=false;
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
//              
//                        }else{
//
//                              throw ex;
//                        }
//                       
//                   }
//                   
//                   if(recordExistence){
//                   
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("4", l_replacedException);
//                   
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ASSIGNMENT_EOD_STATUS_ERROR", l_pkey, column_to_Update,session);   
//                   }else{
//                       
//                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 113,p_instituteID,p_activityID,l_businessDate,l_replacedException);
//                   
//                   }
//            
//            
//            dbg("end of update otherActivity batch error table");
//     }catch(DBValidationException ex){
//          throw ex;
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
//     }catch(Exception ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
//     }
//        
//        
//    }  
//    
//    
//    public void otherActivityProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_activityID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        ITransactionControlService tc=null;
//        try{
//            dbg("inside otherActivityProcessingSuccessHandler");
//            tc=inject.getTransactionControlService();
//            Map<String,String>column_to_Update;
//            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//            IDBTransactionService dbts=inject.getDBTransactionService();
//            BusinessService bs=inject.getBusinessService(session);
//            String endTime=bs.getCurrentDateTime();
//            Map<String,DBRecord>l_studentMap=null;
//            
//            boolean exceptionRaised=false; 
//                try{
//            
//                     l_studentMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_OTHER_ACTIVITY_EOD_STATUS", session, dbSession);
//                     
//                }catch(Exception exe){
//                     exceptionRaised=true;
//                     column_to_Update=new HashMap();
//                     column_to_Update.put("4", "F");
//                     column_to_Update.put("10", endTime);
//                     String[] l_pkey={p_instituteID,p_activityID,l_businessDate};
//                     dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "OTHER_ACTIVITY_EOD_STATUS", l_pkey, column_to_Update,session); 
//                     updateAssignmentErrorTable(l_businessDate,p_instituteID,p_activityID,exe,l_pkey,inject,session,dbSession);
//                }
//            
//             if(!exceptionRaised) {  
//                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_activityID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
//                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_activityID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
//                   dbg("successRecords"+successRecords);
//                   dbg("failedRecords"+failedRecords);
//                   dbg("end time"+endTime);
//          
//                   
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("4", "S");
//                   column_to_Update.put("6", Integer.toString(successRecords));
//                   column_to_Update.put("7", Integer.toString(failedRecords));
//                   column_to_Update.put("10", endTime);
//                   String[] l_pkey={p_instituteID,p_activityID,l_businessDate};
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "OTHER_ACTIVITY_EOD_STATUS", l_pkey, column_to_Update,session);  
//             }
//            dbg("end of otherActivityProcessingSuccessHandler");
//     tc.commit(session, dbSession);
//    }catch(DBValidationException ex){
//         try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(Exception ex){
//           dbg(ex);
//           try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }
//        
//        
//    }
//     public void studentOtherActivityProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_activityID,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        ITransactionControlService tc=null;
//        try{
//            dbg("inside studentOtherActivityProcessingSuccessHandler");
//            tc=inject.getTransactionControlService();
//            Map<String,String>column_to_Update;
//            IDBTransactionService dbts=inject.getDBTransactionService();
//            BusinessService bs=inject.getBusinessService(session);
//            String endTime=bs.getCurrentDateTime();
//            dbg("end time"+endTime);
//            
//            
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("5", "S");
//                   column_to_Update.put("8", endTime);
//                   String[] l_primaryKey={p_instituteID,p_activityID,l_studentID,l_businessDate};
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_OTHER_ACTIVITY_EOD_STATUS", l_primaryKey, column_to_Update,session);
//            
//            dbg("end of studentOtherActivityProcessingSuccessHandler");
//     
//     try{       
//            
//     tc.commit(session, dbSession);
//     
//     }catch(Exception ex){
//         dbg(ex);
//         try{
//          tc.rollBack(session, dbSession);
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("5", "F");
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_OTHER_ACTIVITY_EOD_STATUS", l_primaryKey, column_to_Update,session);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }
//     
//     
//    }catch(DBValidationException ex){
//         try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(Exception ex){
//           dbg(ex);
//           try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }
//        
//        
//    }
//    
//    public void studentOtherActivityProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_otherActivityID,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        ITransactionControlService tc=null;
//        try{
//            dbg("inside studentAssignmentProcessingErrorHandler");
//            dbg("exception"+e);
//            dbg("p_instituteID"+p_instituteID);
//            dbg("l_businessDate"+l_businessDate);
//            dbg("p_otherActivityID"+p_otherActivityID);
//            dbg("l_studentID"+l_studentID);
//            
//            tc=inject.getTransactionControlService();
//            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//            Map<String,String>column_to_Update;
//            IDBTransactionService dbts=inject.getDBTransactionService();
//            BusinessService bs=inject.getBusinessService(session);
//            String endTime=bs.getCurrentDateTime();
//            dbg("end time"+endTime);
//            
//            StringWriter sw = new StringWriter();
//            e.printStackTrace(new PrintWriter(sw));
//            String exceptionAsString = sw.toString();
//            String l_replacedException=getReplacedException(exceptionAsString);
//            
//             try{
//             tc.rollBack(session, dbSession);
//             }catch(DBProcessingException ex1){
//                 dbg(ex1);
//             }
//            
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("5", "F");
//                   column_to_Update.put("8", endTime);
//                   String[] l_primaryKey={p_instituteID,p_otherActivityID,l_studentID,l_businessDate};
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_OTHER_ACTIVITY_EOD_STATUS", l_primaryKey, column_to_Update,session);
//                   
//                   boolean recordExistence=true;
//                   
//                   try{
//                       
//                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_OTHER_ACTIVITY_EOD_STATUS_ERROR", l_primaryKey, session, dbSession,true);
//                       
//                   }catch(DBValidationException ex){
//                       
//                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
//                 
//			  recordExistence=false;
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
//              
//                        }else{
//
//                              throw ex;
//                        }
//                       
//                   }
//                   
//                   if(recordExistence){
//                   
//                       column_to_Update=new HashMap();
//                       column_to_Update.put("5", l_replacedException);
//                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_OTHER_ACTIVITY_EOD_STATUS_ERROR", l_primaryKey, column_to_Update,session);
//                   }else{
//                       
//                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 116, p_instituteID,p_otherActivityID,l_studentID,l_businessDate,l_replacedException);
//                   
//                   }
//                   
//            
//            dbg("inside studentAssignmentProcessingErrorHandler");
//     tc.commit(session, dbSession);
//    }catch(DBValidationException ex){
//         try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(Exception ex){
//           dbg(ex);
//           try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }
//        
//        
//    }
    
    
    
    
    
    
    
    
//     public void feeProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_feeID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        ITransactionControlService tc=null;
//        try{
//            dbg("inside feeProcessingErrorHandler");
//            dbg("exception"+e);
//            tc=inject.getTransactionControlService();
//            Map<String,String>column_to_Update=new HashMap();
//            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//            IDBTransactionService dbts=inject.getDBTransactionService();
//            BusinessService bs=inject.getBusinessService(session);
//            String endTime=bs.getCurrentDateTime();
//            Map<String,DBRecord>l_studentMap=null;
//            
//            
//            try{
//             tc.rollBack(session, dbSession);
//             }catch(DBProcessingException ex1){
//                 dbg(ex1);
//             }
//            
//             boolean exceptionRaised=false; 
//                try{
//            
//                     l_studentMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_FEE_EOD_STATUS", session, dbSession);
//                     
//                }catch(Exception exe){
//                     exceptionRaised=true;
//                     column_to_Update=new HashMap();
//                     column_to_Update.put("4", "F");
//                     column_to_Update.put("10", endTime);
//                     String[] l_pkey={p_instituteID,p_feeID,l_businessDate};
//                     dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_EOD_STATUS", l_pkey, column_to_Update,session); 
//                     updateFeeErrorTable(l_businessDate,p_instituteID,p_feeID,exe,l_pkey,inject,session,dbSession);
//                }  
//               
//                if(!exceptionRaised){
//                   
//                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
//                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
//                   dbg("successRecords"+successRecords);
//                   dbg("failedRecords"+failedRecords);
//                   dbg("end time"+endTime);
//
//                   
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("4", "F");
//                   column_to_Update.put("6", Integer.toString(successRecords));
//                   column_to_Update.put("7", Integer.toString(failedRecords));
//                   column_to_Update.put("10", endTime);
//                   String[] l_pkey={p_instituteID,p_feeID,l_businessDate};
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_EOD_STATUS", l_pkey, column_to_Update,session); 
//                   updateFeeErrorTable(l_businessDate,p_instituteID,p_feeID,e,l_pkey,inject,session,dbSession);
//                   
//                }  
//                   
//                   
//                   
//                   
//            
//            dbg("end of feeProcessingErrorHandler");
//    tc.commit(session, dbSession);
//    }catch(DBValidationException ex){
//         try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(Exception ex){
//           dbg(ex);
//           try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }
//        
//        
//    }
//    
//    
//     private void updateFeeErrorTable(String l_businessDate,String p_instituteID,String p_feeID,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        
//        try{
//            dbg("inside update fee error table");
//            Map<String,String>column_to_Update;
//            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
//            e.printStackTrace(new PrintWriter(sw));
//            String exceptionAsString = sw.toString();
//            String l_replacedException=getReplacedException(exceptionAsString);
//            
//              boolean recordExistence=true;
//                   
//                   try{
//                       
//                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_EOD_STATUS_ERROR", l_pkey, session, dbSession,true);
//                       
//                   }catch(DBValidationException ex){
//                       
//                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
//                 
//			  recordExistence=false;
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
//              
//                        }else{
//
//                              throw ex;
//                        }
//                       
//                   }
//                   
//                   if(recordExistence){
//                   
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("4", l_replacedException);
//                   
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_EOD_STATUS_ERROR", l_pkey, column_to_Update,session);   
//                   }else{
//                       
//                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 119,p_instituteID,p_feeID,l_businessDate,l_replacedException);
//                   
//                   }
//            
//            
//            dbg("end of update fee batch error table");
//     }catch(DBValidationException ex){
//          throw ex;
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
//     }catch(Exception ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
//     }
//        
//        
//    }  
//    
//    
//    public void feeProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_feeID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        ITransactionControlService tc=null;
//        try{
//            dbg("inside feeProcessingSuccessHandler");
//            tc=inject.getTransactionControlService();
//            Map<String,String>column_to_Update;
//            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//            IDBTransactionService dbts=inject.getDBTransactionService();
//            BusinessService bs=inject.getBusinessService(session);
//            String endTime=bs.getCurrentDateTime();
//            Map<String,DBRecord>l_studentMap=null;
//            
//            boolean exceptionRaised=false; 
//                try{
//            
//                     l_studentMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_FEE_EOD_STATUS", session, dbSession);
//                     
//                }catch(Exception exe){
//                     exceptionRaised=true;
//                     column_to_Update=new HashMap();
//                     column_to_Update.put("4", "F");
//                     column_to_Update.put("10", endTime);
//                     String[] l_pkey={p_instituteID,p_feeID,l_businessDate};
//                     dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_EOD_STATUS", l_pkey, column_to_Update,session); 
//                     updateAssignmentErrorTable(l_businessDate,p_instituteID,p_feeID,exe,l_pkey,inject,session,dbSession);
//                }
//            
//             if(!exceptionRaised) {  
//                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
//                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
//                   dbg("successRecords"+successRecords);
//                   dbg("failedRecords"+failedRecords);
//                   dbg("end time"+endTime);
//          
//                   
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("4", "S");
//                   column_to_Update.put("6", Integer.toString(successRecords));
//                   column_to_Update.put("7", Integer.toString(failedRecords));
//                   column_to_Update.put("10", endTime);
//                   String[] l_pkey={p_instituteID,p_feeID,l_businessDate};
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_EOD_STATUS", l_pkey, column_to_Update,session);  
//             }
//            dbg("end of feeProcessingSuccessHandler");
//     tc.commit(session, dbSession);
//    }catch(DBValidationException ex){
//         try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(Exception ex){
//           dbg(ex);
//           try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }
//        
//        
//    }
//     public void studentFeeProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_feeID,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        ITransactionControlService tc=null;
//        try{
//            dbg("inside studentFeeProcessingSuccessHandler");
//            tc=inject.getTransactionControlService();
//            Map<String,String>column_to_Update;
//            IDBTransactionService dbts=inject.getDBTransactionService();
//            BusinessService bs=inject.getBusinessService(session);
//            String endTime=bs.getCurrentDateTime();
//            dbg("end time"+endTime);
//            
//            
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("5", "S");
//                   column_to_Update.put("8", endTime);
//                   String[] l_primaryKey={p_instituteID,p_feeID,l_studentID,l_businessDate};
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_FEE_EOD_STATUS", l_primaryKey, column_to_Update,session);
//            
//            dbg("end of studentFeeProcessingSuccessHandler");
//     
//     try{       
//            
//     tc.commit(session, dbSession);
//     
//     }catch(Exception ex){
//         dbg(ex);
//         try{
//          tc.rollBack(session, dbSession);
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("5", "F");
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_FEE_EOD_STATUS", l_primaryKey, column_to_Update,session);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }
//     
//     
//    }catch(DBValidationException ex){
//         try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(Exception ex){
//           dbg(ex);
//           try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }
//        
//        
//    }
//    
//    public void studentFeeProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_feeID,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
//        ITransactionControlService tc=null;
//        try{
//            dbg("inside studentFeeProcessingErrorHandler");
//            dbg("exception"+e);
//            dbg("p_instituteID"+p_instituteID);
//            dbg("l_businessDate"+l_businessDate);
//            dbg("p_feeID"+p_feeID);
//            dbg("l_studentID"+l_studentID);
//            
//            tc=inject.getTransactionControlService();
//            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
//            Map<String,String>column_to_Update;
//            IDBTransactionService dbts=inject.getDBTransactionService();
//            BusinessService bs=inject.getBusinessService(session);
//            String endTime=bs.getCurrentDateTime();
//            dbg("end time"+endTime);
//            
//            StringWriter sw = new StringWriter();
//            e.printStackTrace(new PrintWriter(sw));
//            String exceptionAsString = sw.toString();
//            String l_replacedException=getReplacedException(exceptionAsString);
//            
//             try{
//             tc.rollBack(session, dbSession);
//             }catch(DBProcessingException ex1){
//                 dbg(ex1);
//             }
//            
//                   column_to_Update=new HashMap();
//                   column_to_Update.put("5", "F");
//                   column_to_Update.put("8", endTime);
//                   String[] l_primaryKey={p_instituteID,p_feeID,l_studentID,l_businessDate};
//                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_FEE_EOD_STATUS", l_primaryKey, column_to_Update,session);
//                   
//                   boolean recordExistence=true;
//                   
//                   try{
//                       
//                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_FEE_EOD_STATUS_ERROR", l_primaryKey, session, dbSession,true);
//                       
//                   }catch(DBValidationException ex){
//                       
//                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
//                 
//			  recordExistence=false;
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
//                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
//              
//                        }else{
//
//                              throw ex;
//                        }
//                       
//                   }
//                   
//                   if(recordExistence){
//                   
//                       column_to_Update=new HashMap();
//                       column_to_Update.put("5", l_replacedException);
//                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_FEE_EOD_STATUS_ERROR", l_primaryKey, column_to_Update,session);
//                   }else{
//                       
//                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 122, p_instituteID,p_feeID,l_studentID,l_businessDate,l_replacedException);
//                   
//                   }
//                   
//            
//            dbg("inside studentFeeProcessingErrorHandler");
//     tc.commit(session, dbSession);
//    }catch(DBValidationException ex){
//         try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(DBProcessingException ex){
//          dbg(ex);
//          try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }catch(Exception ex){
//           dbg(ex);
//           try{
//          tc.rollBack(session, dbSession);
//         }catch(DBProcessingException ex1){
//             dbg(ex1);
//         }
//     }
//        
//        
//    }
    public void otherActivityProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_otherActivityID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside otherActivityProcessingErrorHandler");
            dbg("exception"+e);
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update=new HashMap();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            
            try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
             boolean exceptionRaised=false; 
                try{
            
                     l_studentMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"OtherActivity"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_otherActivityID, "BATCH", "STUDENT_OTHER_ACTIVITY_EOD_STATUS", session, dbSession);
                     
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("4", "F");
                     column_to_Update.put("10", endTime);
                     String[] l_pkey={p_instituteID,p_otherActivityID,l_businessDate};
                     dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "OTHER_ACTIVITY_EOD_STATUS", l_pkey, column_to_Update,session); 
                     tc.commit(session, dbSession);
                     updateOtherActivityErrorTable(l_businessDate,p_instituteID,p_otherActivityID,exe,l_pkey,inject,session,dbSession);
                }  
               
                if(!exceptionRaised){
                   
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_otherActivityID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_otherActivityID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);

                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   column_to_Update.put("10", endTime);
                   String[] l_pkey={p_instituteID,p_otherActivityID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "OTHER_ACTIVITY_EOD_STATUS", l_pkey, column_to_Update,session); 
                   tc.commit(session, dbSession);
                   updateOtherActivityErrorTable(l_businessDate,p_instituteID,p_otherActivityID,e,l_pkey,inject,session,dbSession);
                   
                }  
                   
                   
                   
                   
            
            dbg("end of otherActivityProcessingErrorHandler");
    tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
     private void updateOtherActivityErrorTable(String l_businessDate,String p_instituteID,String p_otherActivityID,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            dbg("inside update otherActivity error table");
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            ITransactionControlService tc=inject.getTransactionControlService();
            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            BusinessService bs=inject.getBusinessService(session);
            String currentTime=bs.getCurrentDateTime();
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
              boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "OTHER_ACTIVITY_EOD_STATUS_ERROR", l_pkey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", l_replacedException);
                   
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "OTHER_ACTIVITY_EOD_STATUS_ERROR", l_pkey, column_to_Update,session);   
                   }else{
                       
                       dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 113,p_instituteID,p_otherActivityID,l_businessDate,l_replacedException);
                   
                   }
            
            tc.commit(session, dbSession);
            dbg("end of update otherActivity batch error table");
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
      }catch(BSProcessingException ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
        
    }  
    
    
    public void otherActivityProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_otherActivityID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside otherActivityProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            boolean exceptionRaised=false; 
                try{
            
                     l_studentMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"OtherActivity"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_otherActivityID, "BATCH", "STUDENT_OTHER_ACTIVITY_EOD_STATUS", session, dbSession);
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("4", "F");
                     column_to_Update.put("10", endTime);
                     String[] l_pkey={p_instituteID,p_otherActivityID,l_businessDate};
                     dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "OTHER_ACTIVITY_EOD_STATUS", l_pkey, column_to_Update,session); 
                     tc.commit(session, dbSession);
                     updateOtherActivityErrorTable(l_businessDate,p_instituteID,p_otherActivityID,exe,l_pkey,inject,session,dbSession);
                }
            
             if(!exceptionRaised) {  
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_otherActivityID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_otherActivityID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);
          
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   column_to_Update.put("10", endTime);
                   String[] l_pkey={p_instituteID,p_otherActivityID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "OTHER_ACTIVITY_EOD_STATUS", l_pkey, column_to_Update,session);  
             }
            dbg("end of otherActivityProcessingSuccessHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
     public void studentOtherActivityProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_otherActivityID,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentOtherActivityProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);

            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "S");
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_otherActivityID,l_studentID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"OtherActivity"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_otherActivityID, "BATCH", "STUDENT_OTHER_ACTIVITY_EOD_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentOtherActivityProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"OtherActivity"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_otherActivityID, "BATCH", "STUDENT_OTHER_ACTIVITY_EOD_STATUS", l_primaryKey, column_to_Update,session);
                   tc.commit(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentOtherActivityProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_otherActivityID,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentOtherActivityProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("p_otherActivityID"+p_otherActivityID);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String currentTime=bs.getCurrentDateTime();
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_otherActivityID,l_studentID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"OtherActivity"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_otherActivityID, "BATCH", "STUDENT_OTHER_ACTIVITY_EOD_STATUS", l_primaryKey, column_to_Update,session);
                   tc.commit(session, dbSession);
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"OtherActivity"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_otherActivityID, "BATCH", "STUDENT_OTHER_ACTIVITY_EOD_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("5", l_replacedException);
                       dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"OtherActivity"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_otherActivityID, "BATCH", "STUDENT_OTHER_ACTIVITY_EOD_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       
                       dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"OtherActivity"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_otherActivityID, "BATCH", 116, p_instituteID,p_otherActivityID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentOtherActivityProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
    
    
    
    public void studentEventNotificationProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentEventNotificationProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);

            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EVENT_NOTIFICATION_EOD_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentEventNotificationProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EVENT_NOTIFICATION_EOD_STATUS", l_primaryKey, column_to_Update,session);
                   tc.commit(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentEventNotificationProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentEventNotificationProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String currentTime=bs.getCurrentDateTime();
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EVENT_NOTIFICATION_EOD_STATUS", l_primaryKey, column_to_Update,session);
                   tc.commit(session, dbSession);
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EVENT_NOTIFICATION_EOD_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EVENT_NOTIFICATION_EOD_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       
                       dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 341, p_instituteID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentEventNotificationProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
    
    
    
    
    public void feeProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_feeID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside feeProcessingErrorHandler");
            dbg("exception"+e);
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update=new HashMap();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            
            try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
             boolean exceptionRaised=false; 
                try{
            
                     l_studentMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Fee"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_EOD_STATUS", session, dbSession);
                     
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("4", "F");
                     column_to_Update.put("10", endTime);
                     String[] l_pkey={p_instituteID,p_feeID,l_businessDate};
                     dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_EOD_STATUS", l_pkey, column_to_Update,session); 
                     tc.commit(session, dbSession);
                     updateFeeErrorTable(l_businessDate,p_instituteID,p_feeID,exe,l_pkey,inject,session,dbSession);
                }  
               
                if(!exceptionRaised){
                   
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);

                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   column_to_Update.put("10", endTime);
                   String[] l_pkey={p_instituteID,p_feeID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_EOD_STATUS", l_pkey, column_to_Update,session); 
                   tc.commit(session, dbSession);
                   updateFeeErrorTable(l_businessDate,p_instituteID,p_feeID,e,l_pkey,inject,session,dbSession);
                   
                }  
                   
                   
                   
                   
            
            dbg("end of feeProcessingErrorHandler");
    tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
     private void updateFeeErrorTable(String l_businessDate,String p_instituteID,String p_feeID,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            dbg("inside update fee error table");
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            ITransactionControlService tc=inject.getTransactionControlService();
            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            BusinessService bs=inject.getBusinessService(session);
            String currentTime=bs.getCurrentDateTime();
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
              boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_EOD_STATUS_ERROR", l_pkey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", l_replacedException);
                   
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_EOD_STATUS_ERROR", l_pkey, column_to_Update,session);   
                   }else{
                       
                       dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 119,p_instituteID,p_feeID,l_businessDate,l_replacedException);
                   
                   }
            
            tc.commit(session, dbSession);
            dbg("end of update fee batch error table");
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
      }catch(BSProcessingException ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
        
    }  
    
    
    public void feeProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_feeID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside feeProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            boolean exceptionRaised=false; 
                try{
            
                     l_studentMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Fee"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_EOD_STATUS", session, dbSession);
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("4", "F");
                     column_to_Update.put("10", endTime);
                     String[] l_pkey={p_instituteID,p_feeID,l_businessDate};
                     dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_EOD_STATUS", l_pkey, column_to_Update,session); 
                     tc.commit(session, dbSession);
                     updateFeeErrorTable(l_businessDate,p_instituteID,p_feeID,exe,l_pkey,inject,session,dbSession);
                }
            
             if(!exceptionRaised) {  
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);
          
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   column_to_Update.put("10", endTime);
                   String[] l_pkey={p_instituteID,p_feeID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_EOD_STATUS", l_pkey, column_to_Update,session);  
             }
            dbg("end of feeProcessingSuccessHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
     public void studentFeeProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_feeID,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentFeeProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
              boolean recordExistence=false;
                     try{
                         
                    
                        Map<String,DBRecord>emailErrorMap= readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Fee"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_EMAIL_ERROR", session, dbSession);
                         
                        List<DBRecord>filteredList=emailErrorMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(2).trim().equals(l_studentID)&&rec.getRecord().get(3).trim().equals(l_businessDate)).collect(Collectors.toList());
                        
                        
                        if(!filteredList.isEmpty()){
                            
                            recordExistence=true;
                        }
                        
                     }catch(DBValidationException ex){
                         
                         if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                             
                             session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                              session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                              recordExistence=false;
                         }
                     }
            
                     
                     if(recordExistence==false){
                         
                         
                         try{

                              Map<String,DBRecord>smsErrorMap= readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Fee"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_SMS_ERROR", session, dbSession);
                         
                              List<DBRecord>filteredList=smsErrorMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(2).trim().equals(l_studentID)&&rec.getRecord().get(3).trim().equals(l_businessDate)).collect(Collectors.toList());
                        
                        
                                if(!filteredList.isEmpty()){

                                    recordExistence=true;
                                }
                             
                             
                         }catch(DBValidationException ex){

                             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){

                                 session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                                  recordExistence=false;
                             }
                         }
                         
                         
                     }
                    String status;
                     if(recordExistence){
                         
                         status="F";
                     }else{
                         
                         status="S";
                     }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", status);
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_feeID,l_studentID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Fee"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_EOD_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentFeeProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Fee"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_EOD_STATUS", l_primaryKey, column_to_Update,session);
                   tc.commit(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentFeeProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_feeID,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentFeeProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("p_feeID"+p_feeID);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String currentTime=bs.getCurrentDateTime();
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_feeID,l_studentID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Fee"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_EOD_STATUS", l_primaryKey, column_to_Update,session);
                   tc.commit(session, dbSession);
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Fee"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_EOD_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("5", l_replacedException);
                       dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Fee"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_EOD_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       
                       dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Fee"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", 122, p_instituteID,p_feeID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentFeeProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void feeNotificationProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_feeID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside feeNotificationProcessingErrorHandler");
            dbg("exception"+e);
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update=new HashMap();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            
            try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
             boolean exceptionRaised=false; 
                try{
            
                     l_studentMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"FeeNotification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_NOTIFICATION_EOD_STATUS", session, dbSession);
                     
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("4", "F");
                     column_to_Update.put("10", endTime);
                     String[] l_pkey={p_instituteID,p_feeID,l_businessDate};
                     dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_NOTIFICATION_EOD_STATUS", l_pkey, column_to_Update,session); 
                     tc.commit(session, dbSession);
                     updateFeeErrorTable(l_businessDate,p_instituteID,p_feeID,exe,l_pkey,inject,session,dbSession);
                }  
               
                if(!exceptionRaised){
                   
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);

                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   column_to_Update.put("10", endTime);
                   String[] l_pkey={p_instituteID,p_feeID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_NOTIFICATION_EOD_STATUS", l_pkey, column_to_Update,session); 
                   tc.commit(session, dbSession);
                   updateFeeNotificationErrorTable(l_businessDate,p_instituteID,p_feeID,e,l_pkey,inject,session,dbSession);
                   
                }  
                   
                   
                   
                   
            
            dbg("end of feeNotificationProcessingErrorHandler");
    tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
     private void updateFeeNotificationErrorTable(String l_businessDate,String p_instituteID,String p_feeID,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            dbg("inside update fee error table");
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            ITransactionControlService tc=inject.getTransactionControlService();
            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            BusinessService bs=inject.getBusinessService(session);
            String currentTime=bs.getCurrentDateTime();
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
              boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_NOTIFICATION_EOD_STATUS_ERROR", l_pkey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", l_replacedException);
                   
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_NOTIFICATION_EOD_STATUS_ERROR", l_pkey, column_to_Update,session);   
                   }else{
                       
                       dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 335,p_instituteID,p_feeID,l_businessDate,l_replacedException);
                   
                   }
            
            tc.commit(session, dbSession);
            dbg("end of update fee batch error table");
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
      }catch(BSProcessingException ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
        
    }  
    
    
    public void feeNotificationProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_feeID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside feeNotificationProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            boolean exceptionRaised=false; 
                try{
            
                     l_studentMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"FeeNotification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_NOTIFICATION_EOD_STATUS", session, dbSession);
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("4", "F");
                     column_to_Update.put("10", endTime);
                     String[] l_pkey={p_instituteID,p_feeID,l_businessDate};
                     dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_NOTIFICATION_EOD_STATUS", l_pkey, column_to_Update,session); 
                     tc.commit(session, dbSession);
                     updateFeeNotificationErrorTable(l_businessDate,p_instituteID,p_feeID,exe,l_pkey,inject,session,dbSession);
                }
            
             if(!exceptionRaised) {  
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_feeID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);
          
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   column_to_Update.put("10", endTime);
                   String[] l_pkey={p_instituteID,p_feeID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "FEE_NOTIFICATION_EOD_STATUS", l_pkey, column_to_Update,session);  
             }
            dbg("end of feeNotificationProcessingSuccessHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
    public void studentFeeNotificationProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_feeID,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentFeeNotificationProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);

            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "S");
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_feeID,l_studentID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"FeeNotification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_NOTIFICATION_EOD_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentFeeNotificationProcessingSuccessHandler");
     
     try{       
            

         
         tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"FeeNotification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_NOTIFICATION_EOD_STATUS", l_primaryKey, column_to_Update,session);
                   tc.commit(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentFeeNotificationProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_feeID,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentFeeNotificationProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("p_feeID"+p_feeID);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String currentTime=bs.getCurrentDateTime();
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_feeID,l_studentID,l_businessDate};
//                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"FeeNotification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_NOTIFICATION_EOD_STATUS", l_primaryKey, column_to_Update,session);
                  dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"FeeNotification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_NOTIFICATION_EOD_STATUS", l_primaryKey, column_to_Update,session);
                   tc.commit(session, dbSession);
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"FeeNotification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_NOTIFICATION_EOD_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("5", l_replacedException);
                       dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"FeeNotification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", "STUDENT_FEE_NOTIFICATION_EOD_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       
                       dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"FeeNotification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_feeID, "BATCH", 338, p_instituteID,p_feeID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentFeeNotificationProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void notificationProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_notificationID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside notificationProcessingErrorHandler");
            dbg("exception"+e);
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update=new HashMap();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            
            try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
             boolean exceptionRaised=false; 
                try{
            
                     l_studentMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_notificationID, "BATCH", "STUDENT_NOTIFICATION_EOD_STATUS", session, dbSession);
                     
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("4", "F");
                     column_to_Update.put("10", endTime);
                     String[] l_pkey={p_instituteID,p_notificationID,l_businessDate};
                     dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "NOTIFICATION_EOD_STATUS", l_pkey, column_to_Update,session); 
                     tc.commit(session, dbSession);
                     updateNotificationErrorTable(l_businessDate,p_instituteID,p_notificationID,exe,l_pkey,inject,session,dbSession);
                }  
               
                if(!exceptionRaised){
                   
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_notificationID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_notificationID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);

                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   column_to_Update.put("10", endTime);
                   String[] l_pkey={p_instituteID,p_notificationID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "NOTIFICATION_EOD_STATUS", l_pkey, column_to_Update,session); 
                   tc.commit(session, dbSession);
                   updateNotificationErrorTable(l_businessDate,p_instituteID,p_notificationID,e,l_pkey,inject,session,dbSession);
                   
                }  
                   
                   
                   
                   
            
            dbg("end of notificationProcessingErrorHandler");
    tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
     private void updateNotificationErrorTable(String l_businessDate,String p_instituteID,String p_notificationID,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            dbg("inside update notification error table");
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            ITransactionControlService tc=inject.getTransactionControlService();
            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            BusinessService bs=inject.getBusinessService(session);
            String currentTime=bs.getCurrentDateTime();
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
              boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "NOTIFICATION_EOD_STATUS_ERROR", l_pkey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", l_replacedException);
                   
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "NOTIFICATION_EOD_STATUS_ERROR", l_pkey, column_to_Update,session);   
                   }else{
                       
                       dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 126,p_instituteID,p_notificationID,l_businessDate,l_replacedException);
                   
                   }
            
            tc.commit(session, dbSession);
            dbg("end of update notification batch error table");
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
      }catch(BSProcessingException ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
        
    }  
    
    
    public void notificationProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_notificationID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside notificationProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            boolean exceptionRaised=false; 
                try{
            
                     l_studentMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_notificationID, "BATCH", "STUDENT_NOTIFICATION_EOD_STATUS", session, dbSession);
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("4", "F");
                     column_to_Update.put("10", endTime);
                     String[] l_pkey={p_instituteID,p_notificationID,l_businessDate};
                     dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "NOTIFICATION_EOD_STATUS", l_pkey, column_to_Update,session); 
                     tc.commit(session, dbSession);
                     updateNotificationErrorTable(l_businessDate,p_instituteID,p_notificationID,exe,l_pkey,inject,session,dbSession);
                }
            
             if(!exceptionRaised) {  
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_notificationID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_notificationID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);
          
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   column_to_Update.put("10", endTime);
                   String[] l_pkey={p_instituteID,p_notificationID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "NOTIFICATION_EOD_STATUS", l_pkey, column_to_Update,session);  
             }
            dbg("end of notificationProcessingSuccessHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
     public void studentNotificationProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_notificationID,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentNotificationProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
              boolean recordExistence=false;
                     try{
                         
                    
                        Map<String,DBRecord>emailErrorMap= readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_notificationID, "BATCH", "STUDENT_NOTIFICATION_EMAIL_ERROR", session, dbSession);
                         
                        List<DBRecord>filteredList=emailErrorMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_notificationID)&&rec.getRecord().get(2).trim().equals(l_studentID)&&rec.getRecord().get(3).trim().equals(l_businessDate)).collect(Collectors.toList());
                        
                        
                        if(!filteredList.isEmpty()){
                            
                            recordExistence=true;
                        }
                        
                     }catch(DBValidationException ex){
                         
                         if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                             
                             session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                              session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                              recordExistence=false;
                         }
                     }
            
                     
                     if(recordExistence==false){
                         
                         
                         try{

                              Map<String,DBRecord>smsErrorMap= readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_notificationID, "BATCH", "STUDENT_NOTIFICATION_SMS_ERROR", session, dbSession);
                         
                              List<DBRecord>filteredList=smsErrorMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_notificationID)&&rec.getRecord().get(2).trim().equals(l_studentID)&&rec.getRecord().get(3).trim().equals(l_businessDate)).collect(Collectors.toList());
                        
                        
                                if(!filteredList.isEmpty()){

                                    recordExistence=true;
                                }
                             
                             
                         }catch(DBValidationException ex){

                             if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){

                                 session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                                  session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                                  recordExistence=false;
                             }
                         }
                         
                         
                     }
                    String status;
                     if(recordExistence){
                         
                         status="F";
                     }else{
                         
                         status="S";
                     }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", status);
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_notificationID,l_studentID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_notificationID, "BATCH", "STUDENT_NOTIFICATION_EOD_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentNotificationProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_notificationID, "BATCH", "STUDENT_NOTIFICATION_EOD_STATUS", l_primaryKey, column_to_Update,session);
                   tc.commit(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentNotificationProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_notificationID,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentNotificationProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("p_notificationID"+p_notificationID);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String currentTime=bs.getCurrentDateTime();
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_notificationID,l_studentID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_notificationID, "BATCH", "STUDENT_NOTIFICATION_EOD_STATUS", l_primaryKey, column_to_Update,session);
                   tc.commit(session, dbSession);
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_notificationID, "BATCH", "STUDENT_NOTIFICATION_EOD_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("5", l_replacedException);
                       dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_notificationID, "BATCH", "STUDENT_NOTIFICATION_EOD_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       
                       dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_notificationID, "BATCH", 129, p_instituteID,p_notificationID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentNotificationProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
    public void updateStudentNotificationStatusTable(String studentID,String notificationID,String businessDate,String endPoint,String status,String error,String instituteID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
       try{
           
          dbg("inside updateStudentNotificationStatusTable");
          dbg("studentID"+studentID);
          dbg("notificationID"+notificationID);
          dbg("businessDate"+businessDate);
          dbg("endPoint"+endPoint);
          dbg("status"+status);
          dbg("error"+error);
          dbg("instituteID"+instituteID);
          ITransactionControlService dbctl=inject.getTransactionControlService();
          IDBTransactionService dbts=inject.getDBTransactionService();
//          ITransactionControlService tc=
          String[] l_pkey={studentID,notificationID,businessDate,endPoint};
          boolean recordExistence =false;
          
          
          try{
          
              dbctl.commit(session, dbSession);
              dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"STUDENT"+i_db_properties.getProperty("FOLDER_DELIMITER")+studentID+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification","STUDENT",309,studentID,notificationID,businessDate,endPoint,status,error);
          
          }catch(DBValidationException ex){
            
              if(ex.toString().contains("DB_VAL_009")){
                  dbctl.rollBack(session, dbSession);
                  recordExistence=true;
              }else {
                  throw ex;
              }
              
              
          }
          
          if(recordExistence){
          
              Map<String,String>l_column_to_update=new HashMap();
              l_column_to_update.put("5", status);
              l_column_to_update.put("6", error);

              dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"STUDENT"+i_db_properties.getProperty("FOLDER_DELIMITER")+studentID+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification","STUDENT", "STUDENT_NOTIFICATION_STATUS", l_pkey, l_column_to_update, session);
           
          }
           
           dbg("end of updateStudentNotificationStatusTable");
       }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     } 
        
    }
    
    public void updateStudentNotificationEMAILAndSMSTable(String instituteID,String notificationID,String studentID,String businessDate,String endPoint,String error,String tableName,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
       try{
           
          dbg("inside updateStudentNotificationStatusTable");
          dbg("studentID"+studentID);
          dbg("notificationID"+notificationID);
          dbg("businessDate"+businessDate);
          dbg("endPoint"+endPoint);
          dbg("error"+error);
          dbg("instituteID"+instituteID);
          IDBTransactionService dbts=inject.getDBTransactionService();
          ITransactionControlService dbctl=inject.getTransactionControlService();
          IMetaDataService mds=inject.getMetadataservice();
          int tableID=mds.getTableMetaData("BATCH", tableName, session).getI_Tableid();
          String[] l_pkey={instituteID,notificationID,studentID,businessDate,endPoint};
          boolean recordExistence =false;
          
          
          try{
          
               dbctl.commit(session, dbSession);
              dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification"+i_db_properties.getProperty("FOLDER_DELIMITER")+notificationID, "BATCH",tableID,instituteID,notificationID,studentID,businessDate,endPoint,error);
          
          
          }catch(DBValidationException ex){
              
              if(ex.toString().contains("DB_VAL_009")){
                  dbctl.rollBack(session, dbSession);
                  recordExistence=true;
              }else{
                  throw ex;
              }
              
              
          }
          
          if(recordExistence){
          
              Map<String,String>l_column_to_update=new HashMap();
              l_column_to_update.put("6", error);

              dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"Notification"+i_db_properties.getProperty("FOLDER_DELIMITER")+notificationID, "BATCH", tableName, l_pkey, l_column_to_update, session);
           
          }
           
           dbg("end of updateStudentNotificationStatusTable");
       }catch(DBValidationException ex){
          throw ex;
//     }catch(BSValidationException ex){
//          throw ex;     
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
//      }catch(BSProcessingException ex){
//           dbg(ex);
//           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     } 
        
    }
    
    public void classTimeTableProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_standard,String p_section,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside ClassTimeTableProcessingErrorHandler");
            dbg("exception"+e);
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update=new HashMap();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            
            try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
             boolean exceptionRaised=false; 
                try{
            
                     l_studentMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_TIMETABLE_BATCH_STATUS", session, dbSession);
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("5", "F");
                     column_to_Update.put("9", endTime);
                     String[] l_pkey={p_instituteID,p_standard,p_section,l_businessDate};
                     dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TIMETABLE_BATCH_STATUS", l_pkey, column_to_Update,session); 
                     updateTimeTableErrorTable(l_businessDate,p_instituteID,p_standard,p_section,exe,l_pkey,inject,session,dbSession);
                }  
               
                if(!exceptionRaised){
                   
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(4).trim().equals(l_businessDate)&&rec.getRecord().get(5).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(4).trim().equals(l_businessDate)&&rec.getRecord().get(5).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);

                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   column_to_Update.put("9", endTime);
                   String[] l_pkey={p_instituteID,p_standard,p_section,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TIMETABLE_BATCH_STATUS", l_pkey, column_to_Update,session); 
                   updateTimeTableErrorTable(l_businessDate,p_instituteID,p_standard,p_section,e,l_pkey,inject,session,dbSession);
                   
                }  
                   
                   
                   
                   
            
            dbg("end of ClassTimeTableProcessingErrorHandler");
    tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
     private void updateTimeTableErrorTable(String l_businessDate,String p_instituteID,String p_standard,String p_section,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            dbg("inside updateTimeTableErrorTable");
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
              boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TIMETABLE_BATCH_STATUS_ERROR", l_pkey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", l_replacedException);
                   
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TIMETABLE_BATCH_STATUS_ERROR", l_pkey, column_to_Update,session);   
                   }else{
                       
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 132,p_instituteID,p_standard,p_section,l_businessDate,l_replacedException);
                   
                   }
            
            
            dbg("end of updateTimeTableErrorTable");
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
      }catch(BSProcessingException ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
        
    }  
    
    
    public void classTimeTableProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_standard,String p_section,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside classTimeTableProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            boolean exceptionRaised=false; 
                try{
            
                     l_studentMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_TIMETABLE_BATCH_STATUS", session, dbSession);
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("5", "F");
                     column_to_Update.put("9", endTime);
                     String[] l_pkey={p_instituteID,p_standard,p_section,l_businessDate};
                     dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TIMETABLE_BATCH_STATUS", l_pkey, column_to_Update,session); 
                     updateTimeTableErrorTable(l_businessDate,p_instituteID,p_standard,p_section,exe,l_pkey,inject,session,dbSession); 
                }
            
             if(!exceptionRaised) {  
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(4).trim().equals(l_businessDate)&&rec.getRecord().get(5).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(4).trim().equals(l_businessDate)&&rec.getRecord().get(5).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);

                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "S");
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   column_to_Update.put("9", endTime);
                   String[] l_pkey={p_instituteID,p_standard,p_section,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TIMETABLE_BATCH_STATUS", l_pkey, column_to_Update,session); 
             }
            dbg("end of classTimeTableProcessingSuccessHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
     public void studentTimeTableProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_standard,String p_section,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentTimeTableProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("6", "S");
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_standard,p_section,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_TIMETABLE_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentTimeTableProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("6", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_TIMETABLE_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentTimeTableProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_standard,String p_section,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentTimeTableProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("6", "F");
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_standard,p_section,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_TIMETABLE_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_TIMETABLE_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("6", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_TIMETABLE_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 135, p_instituteID,p_standard,p_section,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentTimeTableProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
      public void classExamProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_standard,String p_section,String p_exam,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside classExamProcessingErrorHandler");
            dbg("exception"+e);
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update=new HashMap();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            
            try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
             boolean exceptionRaised=false; 
                try{
            
                     l_studentMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EXAM_BATCH_STATUS", session, dbSession);
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("6", "F");
                     column_to_Update.put("10", endTime);
                     String[] l_pkey={p_instituteID,p_standard,p_section,p_exam,l_businessDate};
                     dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "EXAM_BATCH_STATUS", l_pkey, column_to_Update,session); 
                     updateExamErrorTable(l_businessDate,p_instituteID,p_standard,p_section,p_exam,exe,l_pkey,inject,session,dbSession);
                }  
               
                if(!exceptionRaised){
                   
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(3).trim().equals(p_exam)&&rec.getRecord().get(5).trim().equals(l_businessDate)&&rec.getRecord().get(6).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(3).trim().equals(p_exam)&&rec.getRecord().get(5).trim().equals(l_businessDate)&&rec.getRecord().get(6).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);

                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("6", "F");
                   column_to_Update.put("7", Integer.toString(successRecords));
                   column_to_Update.put("8", Integer.toString(failedRecords));
                   column_to_Update.put("10", endTime);
                   String[] l_pkey={p_instituteID,p_standard,p_section,p_exam,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "EXAM_BATCH_STATUS", l_pkey, column_to_Update,session); 
                   updateExamErrorTable(l_businessDate,p_instituteID,p_standard,p_section,p_exam,e,l_pkey,inject,session,dbSession);
                   
                }  
                   
                   
                   
                   
            
            dbg("end of classExamProcessingErrorHandler");
    tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
     private void updateExamErrorTable(String l_businessDate,String p_instituteID,String p_standard,String p_section,String p_exam,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            dbg("inside updateExamErrorTable");
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
              boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "EXAM_BATCH_STATUS_ERROR", l_pkey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("6", l_replacedException);
                   
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "EXAM_BATCH_STATUS_ERROR", l_pkey, column_to_Update,session);   
                   }else{
                       
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 138,p_instituteID,p_standard,p_section,p_exam,l_businessDate,l_replacedException);
                   
                   }
            
            
            dbg("end of updateExamErrorTable");
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
      }catch(BSProcessingException ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
        
    }  
    
    
    public void classExamProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_standard,String p_section,String p_exam,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside classExamProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
           boolean exceptionRaised=false; 
                try{
            
                     l_studentMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EXAM_BATCH_STATUS", session, dbSession);
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("6", "F");
                     column_to_Update.put("10", endTime);
                     String[] l_pkey={p_instituteID,p_standard,p_section,p_exam,l_businessDate};
                     dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "EXAM_BATCH_STATUS", l_pkey, column_to_Update,session); 
                     updateExamErrorTable(l_businessDate,p_instituteID,p_standard,p_section,p_exam,exe,l_pkey,inject,session,dbSession);
                }  
            
             if(!exceptionRaised){
                   
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(3).trim().equals(p_exam)&&rec.getRecord().get(5).trim().equals(l_businessDate)&&rec.getRecord().get(6).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(3).trim().equals(p_exam)&&rec.getRecord().get(5).trim().equals(l_businessDate)&&rec.getRecord().get(6).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);

                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("6", "S");
                   column_to_Update.put("7", Integer.toString(successRecords));
                   column_to_Update.put("8", Integer.toString(failedRecords));
                   column_to_Update.put("10", endTime);
                   String[] l_pkey={p_instituteID,p_standard,p_section,p_exam,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "EXAM_BATCH_STATUS", l_pkey, column_to_Update,session); 
             }
            dbg("end of classExamProcessingSuccessHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
     public void studentExamProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_standard,String p_section,String p_exam,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentExamProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("7", "S");
                   column_to_Update.put("9", endTime);
                   String[] l_primaryKey={p_instituteID,p_standard,p_section,p_exam,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EXAM_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentExamProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("7", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EXAM_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentExamProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_standard,String p_section,String p_exam,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentExamProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("7", "F");
                   column_to_Update.put("9", endTime);
                   String[] l_primaryKey={p_instituteID,p_standard,p_section,p_exam,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EXAM_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EXAM_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("7", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EXAM_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 141, p_instituteID,p_standard,p_section,p_exam,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentExamProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void classMarkProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_standard,String p_section,String p_exam,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside classMarkProcessingErrorHandler");
            dbg("exception"+e);
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update=new HashMap();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            
            
            try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
           

                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("6", "F");
                   column_to_Update.put("7", Integer.toString(0));
                   column_to_Update.put("8", Integer.toString(0));
                   column_to_Update.put("10", endTime);
                   String[] l_pkey={p_instituteID,p_standard,p_section,p_exam,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "MARK_BATCH_STATUS", l_pkey, column_to_Update,session); 
             
                   updateMarkErrorTable(l_businessDate,p_instituteID,p_standard,p_section,p_exam,e,l_pkey,inject,session,dbSession);
                   
                   
                   
                   
                   
            
            dbg("end of classMarkProcessingErrorHandler");
    tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
     private void updateMarkErrorTable(String l_businessDate,String p_instituteID,String p_standard,String p_section,String p_exam,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            dbg("inside updateMarkErrorTable");
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
              boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "MARK_BATCH_STATUS_ERROR", l_pkey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("6", l_replacedException);
                   
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "MARK_BATCH_STATUS_ERROR", l_pkey, column_to_Update,session);   
                   }else{
                       
                       dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 144,p_instituteID,p_standard,p_section,p_exam,l_businessDate,l_replacedException);
                   
                   }
            
            
            dbg("end of updateMarkErrorTable");
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
      }catch(BSProcessingException ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
        
    }  
    
    
    
     public void classMarkProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_standard,String p_section,String p_exam,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside classMarkProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("6", "S");
                   column_to_Update.put("7", Integer.toString(0));
                   column_to_Update.put("8", Integer.toString(0));
                   column_to_Update.put("10", endTime);
                   String[] l_pkey={p_instituteID,p_standard,p_section,p_exam,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "MARK_BATCH_STATUS", l_pkey, column_to_Update,session); 
            dbg("end of classMarkProcessingSuccessHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
     public void studentMarkProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_standard,String p_section,String p_exam,String p_subjectID,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentMarkProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("8", "S");
                   column_to_Update.put("10", endTime);
                   String[] l_primaryKey={p_instituteID,p_standard,p_section,p_exam,p_subjectID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_MARK_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentMarkProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("8", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_MARK_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentMarkProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_standard,String p_section,String p_exam,String p_subjectID,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentMarkProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("8", "F");
                   column_to_Update.put("10", endTime);
                   String[] l_primaryKey={p_instituteID,p_standard,p_section,p_exam,p_subjectID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_MARK_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_MARK_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("8", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_MARK_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 147, p_instituteID,p_standard,p_section,p_exam,p_subjectID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentMarkProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    public void classAttendanceProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_standard,String p_section,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside ClassAttendanceProcessingErrorHandler");
            dbg("exception"+e);
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update=new HashMap();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            
            try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
             boolean exceptionRaised=false; 
                try{
            
                     l_studentMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ATTENDANCE_BATCH_STATUS", session, dbSession);
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("5", "F");
                     column_to_Update.put("9", endTime);
                     String[] l_pkey={p_instituteID,p_standard,p_section,l_businessDate};
                     dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ATTENDANCE_BATCH_STATUS", l_pkey, column_to_Update,session); 
                     updateAttendanceErrorTable(l_businessDate,p_instituteID,p_standard,p_section,exe,l_pkey,inject,session,dbSession);
                }  
               
                if(!exceptionRaised){
                   
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(4).trim().equals(l_businessDate)&&rec.getRecord().get(5).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(4).trim().equals(l_businessDate)&&rec.getRecord().get(5).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);

                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   column_to_Update.put("9", endTime);
                   String[] l_pkey={p_instituteID,p_standard,p_section,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ATTENDANCE_BATCH_STATUS", l_pkey, column_to_Update,session); 
                   updateAttendanceErrorTable(l_businessDate,p_instituteID,p_standard,p_section,e,l_pkey,inject,session,dbSession);
                   
                }  
                   
                   
                   
                   
            
            dbg("end of ClassAttendanceProcessingErrorHandler");
    tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
     private void updateAttendanceErrorTable(String l_businessDate,String p_instituteID,String p_standard,String p_section,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            dbg("inside updateAttendanceErrorTable");
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
              boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ATTENDANCE_BATCH_STATUS_ERROR", l_pkey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", l_replacedException);
                   
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ATTENDANCE_BATCH_STATUS_ERROR", l_pkey, column_to_Update,session);   
                   }else{
                       
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 150,p_instituteID,p_standard,p_section,l_businessDate,l_replacedException);
                   
                   }
            
            
            dbg("end of updateAttendanceErrorTable");
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
      }catch(BSProcessingException ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
        
    }  
    
    
    public void classAttendanceProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_standard,String p_section,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside classAttendanceProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            boolean exceptionRaised=false; 
                try{
            
                     l_studentMap=   readBuffer.readTable("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ATTENDANCE_BATCH_STATUS", session, dbSession);
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("5", "F");
                     column_to_Update.put("9", endTime);
                     String[] l_pkey={p_instituteID,p_standard,p_section,l_businessDate};
                     dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ATTENDANCE_BATCH_STATUS", l_pkey, column_to_Update,session); 
                     updateAttendanceErrorTable(l_businessDate,p_instituteID,p_standard,p_section,exe,l_pkey,inject,session,dbSession); 
                }
            
             if(!exceptionRaised) {  
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(4).trim().equals(l_businessDate)&&rec.getRecord().get(5).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_standard)&&rec.getRecord().get(2).trim().equals(p_section)&&rec.getRecord().get(4).trim().equals(l_businessDate)&&rec.getRecord().get(5).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);

                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "S");
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   column_to_Update.put("9", endTime);
                   String[] l_pkey={p_instituteID,p_standard,p_section,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ATTENDANCE_BATCH_STATUS", l_pkey, column_to_Update,session); 
             }
            dbg("end of classAttendanceProcessingSuccessHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
     public void studentAttendanceProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_standard,String p_section,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentAttendanceProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("6", "S");
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_standard,p_section,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ATTENDANCE_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentAttendanceProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("6", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ATTENDANCE_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentAttendanceProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_standard,String p_section,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentAttendanceProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("6", "F");
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_standard,p_section,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ATTENDANCE_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ATTENDANCE_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("6", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ATTENDANCE_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 153, p_instituteID,p_standard,p_section,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentAttendanceProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
    public void studentAssignmentArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentAssignmentArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ASSIGNMENT_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentAssignmentArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ASSIGNMENT_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentAssignmentArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentAssignmentArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ASSIGNMENT_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ASSIGNMENT_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ASSIGNMENT_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 156, p_instituteID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentAssignmentArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void instituteAssignmentArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside instituteAssignmentArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "S");
                   column_to_Update.put("5", endTime);
                   String[] l_primaryKey={p_instituteID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_ASSIGNMENT_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of instituteAssignmentArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_ASSIGNMENT_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void instituteAssignmentArchProcessingErrorHandler(String p_instituteID,String l_businessDate,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside instituteAssignmentArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "F");
                   column_to_Update.put("5", endTime);
                   String[] l_primaryKey={p_instituteID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_ASSIGNMENT_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_ASSIGNMENT_ARCH_BATCH_STATUS", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("3", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_ASSIGNMENT_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 159, p_instituteID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside instituteAssignmentArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
     public void studentOtherActivityArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentOtherActivityArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_OTHER_ACTIVITY_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentOtherActivityArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_OTHER_ACTIVITY_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentOtherActivityArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentOtherActivityArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_OTHER_ACTIVITY_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_OTHER_ACTIVITY_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                      if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_OTHER_ACTIVITY_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "STUDENT_OTHER_ACTIVITY_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentOtherActivityArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void instituteOtherActivityArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside instituteOtherActivityArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "S");
                   column_to_Update.put("5", endTime);
                   String[] l_primaryKey={p_instituteID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_OTHER_ACTIVITY_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of instituteOtherActivityArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_OTHER_ACTIVITY_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void instituteOtherActivityArchProcessingErrorHandler(String p_instituteID,String l_businessDate,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside instituteOtherActivityArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "F");
                   column_to_Update.put("5", endTime);
                   String[] l_primaryKey={p_instituteID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_OTHER_ACTIVITY_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_OTHER_ACTIVITY_ARCH_BATCH_STATUS", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("3", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_OTHER_ACTIVITY_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "INSTITUTE_OTHER_ACTIVITY_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside instituteOtherActivityArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
     public void studentFeeArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentFeeArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_FEE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentFeeArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_FEE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentFeeArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentFeeArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_FEE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_FEE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_FEE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "STUDENT_FEE_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentFeeArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void instituteFeeArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside instituteFeeArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "S");
                   column_to_Update.put("5", endTime);
                   String[] l_primaryKey={p_instituteID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_FEE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of instituteFeeArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_FEE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void instituteFeeArchProcessingErrorHandler(String p_instituteID,String l_businessDate,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside instituteFeeArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "F");
                   column_to_Update.put("5", endTime);
                   String[] l_primaryKey={p_instituteID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_FEE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_FEE_ARCH_BATCH_STATUS", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("3", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_FEE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "INSTITUTE_FEE_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside instituteFeeArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
     public void studentNotificationArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentNotificationArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_NOTIFICATION_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentNotificationArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_NOTIFICATION_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentNotificationArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentNotificationArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_NOTIFICATION_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_NOTIFICATION_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                      if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_NOTIFICATION_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "STUDENT_NOTIFICATION_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentNotificationArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void instituteNotificationArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside instituteNotificationArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "S");
                   column_to_Update.put("5", endTime);
                   String[] l_primaryKey={p_instituteID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_NOTIFICATION_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of instituteNotificationArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_NOTIFICATION_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void instituteNotificationArchProcessingErrorHandler(String p_instituteID,String l_businessDate,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside instituteNotificationArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "F");
                   column_to_Update.put("5", endTime);
                   String[] l_primaryKey={p_instituteID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_NOTIFICATION_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_NOTIFICATION_ARCH_BATCH_STATUS", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("3", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_NOTIFICATION_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "INSTITUTE_NOTIFICATION_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside instituteNotificationArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
    public void studentMarkArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentMarkArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_MARK_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentMarkArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_MARK_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentMarkArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentMarkArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_MARK_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_MARK_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_MARK_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "STUDENT_MARK_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentMarkArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
 
    
     public void classMarkArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_standard,String l_section,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside classMarkArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "S");
                   column_to_Update.put("7", endTime);
                   String[] l_primaryKey={p_instituteID,l_standard,l_section,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_MARK_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of classMarkArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_MARK_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void classMarkArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_standard,String l_section,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside classMarkArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_standard"+l_standard);
             dbg("l_section"+l_section);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   column_to_Update.put("7", endTime);
                   String[] l_primaryKey={p_instituteID,l_standard,l_section,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_MARK_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_MARK_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("5", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_MARK_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "CLASS_MARK_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_standard,l_section,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside classMarkArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
     public void studentExamArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentExamArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EXAM_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentExamArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EXAM_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentExamArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentExamArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EXAM_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EXAM_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_EXAM_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "STUDENT_EXAM_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentExamArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
 
    
     public void classExamArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_standard,String l_section,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside classExamArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "S");
                   column_to_Update.put("7", endTime);
                   String[] l_primaryKey={p_instituteID,l_standard,l_section,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_EXAM_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of classExamArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_EXAM_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void classExamArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_standard,String l_section,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside classExamArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_standard"+l_standard);
             dbg("l_section"+l_section);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   column_to_Update.put("7", endTime);
                   String[] l_primaryKey={p_instituteID,l_standard,l_section,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_EXAM_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_EXAM_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("5", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_EXAM_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "CLASS_EXAM_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_standard,l_section,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside classExamArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentTimeTableArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentTimeTableArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_TIME_TABLE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentTimeTableArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_TIME_TABLE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentTimeTableArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentTimeTableArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_TIME_TABLE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_TIME_TABLE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_TIME_TABLE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "STUDENT_TIME_TABLE_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentTimeTableArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
 
    
     public void classTimeTableArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_standard,String l_section,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside classTimeTableArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "S");
                   column_to_Update.put("7", endTime);
                   String[] l_primaryKey={p_instituteID,l_standard,l_section,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_TIME_TABLE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of classTimeTableArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_TIME_TABLE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void classTimeTableArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_standard,String l_section,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside classTimeTableArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_standard"+l_standard);
             dbg("l_section"+l_section);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   column_to_Update.put("7", endTime);
                   String[] l_primaryKey={p_instituteID,l_standard,l_section,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_TIME_TABLE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_TIME_TABLE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("5", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_TIME_TABLE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "CLASS_TIME_TABLE_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_standard,l_section,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside classTimeTableArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentAttendanceArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentAttendanceArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ATTENDANCE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentAttendanceArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ATTENDANCE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentAttendanceArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentAttendanceArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ATTENDANCE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ATTENDANCE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_ATTENDANCE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "STUDENT_ATTENDANCE_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentAttendanceArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
 
    
     public void classAttendanceArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_standard,String l_section,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside classAttendanceArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "S");
                   column_to_Update.put("7", endTime);
                   String[] l_primaryKey={p_instituteID,l_standard,l_section,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_ATTENDANCE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of classAttendanceArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_ATTENDANCE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void classAttendanceArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_standard,String l_section,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside classAttendanceArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_standard"+l_standard);
             dbg("l_section"+l_section);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   column_to_Update.put("7", endTime);
                   String[] l_primaryKey={p_instituteID,l_standard,l_section,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_ATTENDANCE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_ATTENDANCE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("5", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "CLASS_ATTENDANCE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "CLASS_ATTENDANCE_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_standard,l_section,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside classAttendanceArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
     public void studentLeaveArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentLeaveArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_LEAVE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentLeaveArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_LEAVE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentLeaveArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentLeaveArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_LEAVE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_LEAVE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_LEAVE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "STUDENT_LEAVE_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentLeaveArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
     public void teacherLeaveArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_teacherID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside teacherLeaveArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_teacherID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_LEAVE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of teacherLeaveArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_LEAVE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void teacherLeaveArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_teacherID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside teacherLeaveArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_teacherID"+l_teacherID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_teacherID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_LEAVE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_LEAVE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_LEAVE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "TEACHER_LEAVE_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_teacherID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside teacherLeaveArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
     public void studentCalenderArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentCalenderArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_CALENDER_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentCalenderArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_CALENDER_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentCalenderArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentCalenderArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_CALENDER_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_CALENDER_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_CALENDER_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "STUDENT_CALENDER_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentCalenderArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
     public void teacherCalenderArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_teacherID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside teacherCalenderArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_teacherID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_CALENDER_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of teacherCalenderArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_CALENDER_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void teacherCalenderArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_teacherID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside teacherCalenderArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_teacherID"+l_teacherID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_teacherID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_CALENDER_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_CALENDER_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                      if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_CALENDER_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "TEACHER_CALENDER_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_teacherID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside teacherCalenderArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
    public void teacherPayrollArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_teacherID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside teacherPayrollArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_teacherID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_PAYROLL_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of teacherPayrollArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_PAYROLL_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void teacherPayrollArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_teacherID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside teacherPayrollArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_teacherID"+l_teacherID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_teacherID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_PAYROLL_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_PAYROLL_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_PAYROLL_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "TEACHER_PAYROLL_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_teacherID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside teacherPayrollArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    public void studentPaymentArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentPaymentArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_PAYMENT_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentPaymentArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_PAYMENT_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentPaymentArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentPaymentArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_PAYMENT_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_PAYMENT_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                      if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_PAYMENT_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "STUDENT_PAYMENT_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentPaymentArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void institutePaymentArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside institutePaymentArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "S");
                   column_to_Update.put("5", endTime);
                   String[] l_primaryKey={p_instituteID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_PAYMENT_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of institutePaymentArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_PAYMENT_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void institutePaymentArchProcessingErrorHandler(String p_instituteID,String l_businessDate,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside institutePaymentArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "F");
                   column_to_Update.put("5", endTime);
                   String[] l_primaryKey={p_instituteID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_PAYMENT_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_PAYMENT_ARCH_BATCH_STATUS", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("3", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "INSTITUTE_PAYMENT_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "INSTITUTE_PAYMENT_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside institutePaymentArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void teacherAttendanceArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_teacherID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside teacherAttendanceArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_teacherID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_ATTENDANCE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of teacherAttendanceArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_ATTENDANCE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void teacherAttendanceArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_teacherID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside teacherAttendanceArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_teacherID"+l_teacherID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_teacherID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_ATTENDANCE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_ATTENDANCE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_ATTENDANCE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "TEACHER_ATTENDANCE_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_teacherID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside teacherAttendanceArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void teacherTimeTableArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_teacherID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside teacherTimeTableArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_teacherID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_TIME_TABLE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of teacherTimeTableArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_TIME_TABLE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void teacherTimeTableArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_teacherID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside teacherTimeTableArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_teacherID"+l_teacherID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_teacherID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_TIME_TABLE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_TIME_TABLE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_TIME_TABLE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "TEACHER_TIME_TABLE_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_teacherID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside teacherTimeTableArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentProfileArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentProfileArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_PROFILE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentProfileArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_PROFILE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentProfileArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentProfileArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_studentID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_PROFILE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_PROFILE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                      if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "STUDENT_PROFILE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "STUDENT_PROFILE_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentProfileArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
     public void teacherProfileArchProcessingSuccessHandler(String p_instituteID,String l_businessDate,String l_teacherID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside teacherProfileArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_teacherID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_PROFILE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of teacherProfileArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_PROFILE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void teacherProfileArchProcessingErrorHandler(String p_instituteID,String l_businessDate,String l_teacherID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside teacherProfileArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_teacherID"+l_teacherID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", endTime);
                   String[] l_primaryKey={p_instituteID,l_teacherID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_PROFILE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_PROFILE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("4", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "TEACHER_PROFILE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "TEACHER_PROFILE_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, p_instituteID,l_teacherID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside teacherProfileArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void userProfileArchProcessingSuccessHandler(String l_businessDate,String l_userID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside userProfileArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "S");
                   column_to_Update.put("5", endTime);
                   String[] l_primaryKey={l_userID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "USER_PROFILE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of userProfileArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "USER_PROFILE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void userProfileArchProcessingErrorHandler(String l_businessDate,String l_userID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside userProfileArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_userID"+l_userID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "F");
                   column_to_Update.put("5", endTime);
                   String[] l_primaryKey={l_userID,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "USER_PROFILE_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "USER_PROFILE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                      if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("3", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "USER_PROFILE_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "USER_PROFILE_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, l_userID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside userProfileArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
    public void defragmentationProcessingSuccessHandler(String l_businessDate,String l_fileName,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside defragmentationArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "S");
                   column_to_Update.put("5", endTime);
                   String[] l_primaryKey={l_fileName,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "DEFRAGMENTATION_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of defragmentationArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "DEFRAGMENTATION_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
        dbg(ex);
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void defragmentationProcessingErrorHandler(String l_businessDate,String l_fileName,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside defragmentationArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_fileName"+l_fileName);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("3", "F");
                   column_to_Update.put("5", endTime);
                   String[] l_primaryKey={l_fileName,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "DEFRAGMENTATION_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "DEFRAGMENTATION_BATCH_STATUS", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("3", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "DEFRAGMENTATION_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "DEFRAGMENTATION_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, l_fileName,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside defragmentationArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    public void archivalRecoveryProcessingSuccessHandler(String l_businessDate,String l_fileName,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside archivalRecoveryArchProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("2", "S");
                   column_to_Update.put("4", endTime);
                   String[] l_primaryKey={l_fileName,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ARCHIVAL_RECOVERY_BATCH_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of archivalRecoveryArchProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("2", "F");
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ARCHIVAL_RECOVERY_ARCH_BATCH_STATUS", l_primaryKey, column_to_Update,session);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
        dbg(ex);
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void archivalRecoveryProcessingErrorHandler(String l_businessDate,String l_fileName,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside archivalRecoveryArchProcessingErrorHandler");
            dbg("exception"+e);
            dbg("l_businessDate"+l_businessDate);
            dbg("l_fileName"+l_fileName);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String l_replacedException=getReplacedException(exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("2", "F");
                   column_to_Update.put("4", endTime);
                   String[] l_primaryKey={l_fileName,l_businessDate};
                   dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ARCHIVAL_RECOVERY_BATCH_STATUS", l_primaryKey, column_to_Update,session);
                   
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ARCHIVAL_RECOVERY_BATCH_STATUS", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("2", l_replacedException);
                       dbts.updateColumn("BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "ARCHIVAL_RECOVERY_ARCH_BATCH_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       IMetaDataService mds=inject.getMetadataservice();
                       int tableId=mds.getTableMetaData("BATCH", "ARCHIVAL_RECOVERY_ARCH_BATCH_STATUS_ERROR",session).getI_Tableid();
                       dbg("tableId"+tableId);
                       dbts.createRecord(session,"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", tableId, l_fileName,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside archivalRecoveryArchProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void eCircularProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_eCircularID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession,String circularType)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside eCircularProcessingErrorHandler");
            dbg("exception"+e);
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update=new HashMap();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            
            try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
             boolean exceptionRaised=false; 
                try{
            
                    
                    
                   if(circularType.equals("S")){
                    
                     l_studentMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", "STUDENT_E_CIRCULAR_EOD_STATUS", session, dbSession);
                     
                    }else{
                        
                        
                        l_studentMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", "TEACHER_E_CIRCULAR_EOD_STATUS", session, dbSession);
                    }                     
                     
                     
                     
                     
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("4", "F");
                     column_to_Update.put("10", endTime);
                     String[] l_pkey={p_instituteID,p_eCircularID,l_businessDate};
                     dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "E_CIRCULAR_EOD_STATUS", l_pkey, column_to_Update,session); 
                     tc.commit(session, dbSession);
                     updateECircularErrorTable(l_businessDate,p_instituteID,p_eCircularID,exe,l_pkey,inject,session,dbSession);
                }  
               
                if(!exceptionRaised){
                   
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_eCircularID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_eCircularID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);

                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "F");
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   column_to_Update.put("10", endTime);
                   String[] l_pkey={p_instituteID,p_eCircularID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "E_CIRCULAR_EOD_STATUS", l_pkey, column_to_Update,session); 
                   tc.commit(session, dbSession);
                   updateECircularErrorTable(l_businessDate,p_instituteID,p_eCircularID,e,l_pkey,inject,session,dbSession);
                   
                }  
                   
                   
                   
                   
            
            dbg("end of eCircularProcessingErrorHandler");
    tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
     private void updateECircularErrorTable(String l_businessDate,String p_instituteID,String p_eCircularID,Exception e,String[] l_pkey,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        
        try{
            dbg("inside update eCircular error table");
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            ITransactionControlService tc=inject.getTransactionControlService();
            IDBTransactionService dbts=inject.getDBTransactionService();StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            BusinessService bs=inject.getBusinessService(session);
            String currentTime=bs.getCurrentDateTime();
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
              boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "E_CIRCULAR_EOD_STATUS_ERROR", l_pkey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", l_replacedException);
                   
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "E_CIRCULAR_EOD_STATUS_ERROR", l_pkey, column_to_Update,session);   
                   }else{
                       
                       dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", 294,p_instituteID,p_eCircularID,l_businessDate,l_replacedException);
                   
                   }
            
            tc.commit(session, dbSession);
            dbg("end of update eCircular batch error table");
     }catch(DBValidationException ex){
          throw ex;
     }catch(DBProcessingException ex){
          dbg(ex);
          throw new DBProcessingException("DBProcessingException"+ex.toString());
      }catch(BSProcessingException ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }catch(Exception ex){
           dbg(ex);
           throw new BSProcessingException(ex.toString());
     }
        
        
    }  
    
    
    public void eCircularProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_eCircularID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession,String circularType)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside eCircularProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            Map<String,DBRecord>l_studentMap=null;
            
            boolean exceptionRaised=false; 
                try{
            
                    
                    if(circularType.equals("S")){
                    
                     l_studentMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", "STUDENT_E_CIRCULAR_EOD_STATUS", session, dbSession);
                     
                    }else{
                        
                        
                        l_studentMap=   readBuffer.readTable("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", "TEACHER_E_CIRCULAR_EOD_STATUS", session, dbSession);
                    }
                     
                     
                }catch(Exception exe){
                     exceptionRaised=true;
                     column_to_Update=new HashMap();
                     column_to_Update.put("4", "F");
                     column_to_Update.put("10", endTime);
                     String[] l_pkey={p_instituteID,p_eCircularID,l_businessDate};
                     dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "E_CIRCULAR_EOD_STATUS", l_pkey, column_to_Update,session); 
                     tc.commit(session, dbSession);
                     updateECircularErrorTable(l_businessDate,p_instituteID,p_eCircularID,exe,l_pkey,inject,session,dbSession);
                }
            
             if(!exceptionRaised) {  
                   int successRecords= l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_eCircularID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("S")).collect(Collectors.toList()).size();
                   int failedRecords=  l_studentMap.values().stream().filter(rec->rec.getRecord().get(0).trim().equals(p_instituteID)&&rec.getRecord().get(1).trim().equals(p_eCircularID)&&rec.getRecord().get(3).trim().equals(l_businessDate)&&rec.getRecord().get(4).trim().equals("F")).collect(Collectors.toList()).size();
                   dbg("successRecords"+successRecords);
                   dbg("failedRecords"+failedRecords);
                   dbg("end time"+endTime);
          
                   
                   column_to_Update=new HashMap();
                   column_to_Update.put("4", "S");
                   column_to_Update.put("6", Integer.toString(successRecords));
                   column_to_Update.put("7", Integer.toString(failedRecords));
                   column_to_Update.put("10", endTime);
                   String[] l_pkey={p_instituteID,p_eCircularID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate, "BATCH", "E_CIRCULAR_EOD_STATUS", l_pkey, column_to_Update,session);  
             }
            dbg("end of eCircularProcessingSuccessHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
     public void studentECircularProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_eCircularID,String l_studentID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentECircularProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);

            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "S");
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_eCircularID,l_studentID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", "STUDENT_E_CIRCULAR_EOD_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of studentECircularProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", "STUDENT_E_CIRCULAR_EOD_STATUS", l_primaryKey, column_to_Update,session);
                   tc.commit(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void studentECircularProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_eCircularID,String l_studentID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside studentECircularProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("p_eCircularID"+p_eCircularID);
            dbg("l_studentID"+l_studentID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String currentTime=bs.getCurrentDateTime();
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_eCircularID,l_studentID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", "STUDENT_E_CIRCULAR_EOD_STATUS", l_primaryKey, column_to_Update,session);
                   tc.commit(session, dbSession);
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", "STUDENT_E_CIRCULAR_EOD_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("5", l_replacedException);
                       dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", "STUDENT_E_CIRCULAR_EOD_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       
                       dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", 297, p_instituteID,p_eCircularID,l_studentID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside studentECircularProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    
    
    public void teacherECircularProcessingSuccessHandler(String p_instituteID,String l_businessDate,String p_eCircularID,String l_teacherID,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside teacherECircularProcessingSuccessHandler");
            tc=inject.getTransactionControlService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);

            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "S");
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_eCircularID,l_teacherID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", "TEACHER_E_CIRCULAR_EOD_STATUS", l_primaryKey, column_to_Update,session);
            
            dbg("end of teacherECircularProcessingSuccessHandler");
     
     try{       
            
     tc.commit(session, dbSession);
     
     }catch(Exception ex){
         dbg(ex);
         try{
          tc.rollBack(session, dbSession);
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", "TEACHER_E_CIRCULAR_EOD_STATUS", l_primaryKey, column_to_Update,session);
                   tc.commit(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
     
     
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    
    public void teacherECircularProcessingErrorHandler(String p_instituteID,String l_businessDate,String p_eCircularID,String l_teacherID,Exception e,AppDependencyInjection inject,CohesiveSession session,DBSession dbSession)throws DBValidationException,DBProcessingException,BSProcessingException{
        ITransactionControlService tc=null;
        try{
            dbg("inside teacherECircularProcessingErrorHandler");
            dbg("exception"+e);
            dbg("p_instituteID"+p_instituteID);
            dbg("l_businessDate"+l_businessDate);
            dbg("p_eCircularID"+p_eCircularID);
            dbg("l_teacherID"+l_teacherID);
            
            tc=inject.getTransactionControlService();
            IDBReadBufferService readBuffer=inject.getDBReadBufferService();
            Map<String,String>column_to_Update;
            IDBTransactionService dbts=inject.getDBTransactionService();
            BusinessService bs=inject.getBusinessService(session);
            String endTime=bs.getCurrentDateTime();
            dbg("end time"+endTime);
            
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            String exceptionAsString = sw.toString();
            String currentTime=bs.getCurrentDateTime();
            String l_replacedException=getReplacedException(currentTime+exceptionAsString);
            
             try{
             tc.rollBack(session, dbSession);
             }catch(DBProcessingException ex1){
                 dbg(ex1);
             }
            
                   column_to_Update=new HashMap();
                   column_to_Update.put("5", "F");
                   column_to_Update.put("8", endTime);
                   String[] l_primaryKey={p_instituteID,p_eCircularID,l_teacherID,l_businessDate};
                   dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", "TEACHER_E_CIRCULAR_EOD_STATUS", l_primaryKey, column_to_Update,session);
                   tc.commit(session, dbSession);
                   boolean recordExistence=true;
                   
                   try{
                       
                       readBuffer.readRecord("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", "TEACHER_E_CIRCULAR_EOD_STATUS_ERROR", l_primaryKey, session, dbSession,true);
                       
                   }catch(DBValidationException ex){
                       
                       if(ex.toString().contains("DB_VAL_011")||ex.toString().contains("DB_VAL_000")){
                 
			  recordExistence=false;
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_011");
                          session.getErrorhandler().removeSessionErrCode("DB_VAL_000");  
              
                        }else{

                              throw ex;
                        }
                       
                   }
                   
                   if(recordExistence){
                   
                       column_to_Update=new HashMap();
                       column_to_Update.put("5", l_replacedException);
                       dbts.updateColumn("INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", "TEACHER_E_CIRCULAR_EOD_STATUS_ERROR", l_primaryKey, column_to_Update,session);
                   }else{
                       
                       dbts.createRecord(session,"INSTITUTE"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_instituteID+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+l_businessDate+i_db_properties.getProperty("FOLDER_DELIMITER")+"BATCH"+i_db_properties.getProperty("FOLDER_DELIMITER")+"ECircular"+i_db_properties.getProperty("FOLDER_DELIMITER")+p_eCircularID, "BATCH", 351, p_instituteID,p_eCircularID,l_teacherID,l_businessDate,l_replacedException);
                   
                   }
                   
            
            dbg("inside teacherECircularProcessingErrorHandler");
     tc.commit(session, dbSession);
    }catch(DBValidationException ex){
         try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(DBProcessingException ex){
          dbg(ex);
          try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }catch(Exception ex){
           dbg(ex);
           try{
          tc.rollBack(session, dbSession);
         }catch(DBProcessingException ex1){
             dbg(ex1);
         }
     }
        
        
    }
    public void dbg(String p_Value) {

        this.debug.dbg(p_Value);

    }

    public void dbg(Exception ex) {

        this.debug.exceptionDbg(ex);

    }
}
